{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"about/","title":"About GeoPython Learn","text":"<p>Our mission is to provide accessible, high-quality resources for geologists and learners to master Python in geological applications.</p> <p>Our mission is to provide accessible, high-quality resources for geologists and learners to master Python in geological applications.</p>"},{"location":"resources/","title":"Resources","text":"<ul> <li>Python Official Documentation</li> <li>Pandas for Data Analysis</li> <li>Matplotlib for Visualization</li> </ul>"},{"location":"support/","title":"Support by","text":""},{"location":"support/#thanks-for-our-sponsor","title":"Thanks For Our Sponsor","text":""},{"location":"geology/geology%20structure/none/","title":"Empty","text":""},{"location":"geology/geology%20structure/none/#hopefully-will-done-sooner","title":"Hopefully will Done Sooner","text":""},{"location":"geology/petrology/none/","title":"Empty","text":""},{"location":"geology/petrology/none/#hopefully-will-done-sooner","title":"Hopefully will Done Sooner","text":""},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/","title":"3D Geological Model with Gempy","text":""},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#pendahuluan","title":"Pendahuluan","text":"<p>Panduan ini disusun menggunakan Python dengan library seperti <code>pandas</code>, <code>numpy</code>, <code>gempy</code>, dan <code>gempy_viewer</code> untuk memproses data drill hole (collar, survey, litologi, dan assay) serta membuat model geologi 3D. Data yang digunakan dalam tutorial ini menggunakan data endapan nikel laterit dengan litologi seperti LIM (limonit), SAP (saprolit), dan BZ (batuan dasar). Adapun proses yang dilakukan meliputi penginputan data, desurvey drill hole, pengolahan litologi, pengaturan model geologi, penghitungan, dan visualisasi hasil dalam 2D dan 3D.</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-1-pengaturan-dan-impor-library","title":"Blok 1: Pengaturan dan Impor library","text":"<p><pre><code># Install library yang diperlukan jika belum terinstall\n# pip install pandas numpy pyvista matplotlib gempy gempy_viewer\n\nimport os\nos.environ[\"DEFAULT_BACKEND\"] = \"PYTORCH\"\n\nimport pandas as pd\nimport numpy as np\nimport gempy as gp\nimport gempy_viewer as gpv\nfrom pyvista import set_plot_theme\nset_plot_theme('document')\n</code></pre> Tujuan: Menyiapkan environment dengan mengimpor library yang diperlukan dan mengatur konfigurasi.</p> <p>Langkah-langkah:</p> <ul> <li>Mengatur variabel environment <code>DEFAULT_BACKEND</code> ke <code>\"PYTORCH\"</code> untuk perhitungan GemPy (PyTorch digunakan untuk operasi numerik yang lebih cepat).</li> <li>Mengimpor <code>pandas</code> untuk penanganan data, <code>numpy</code> untuk operasi numerik, <code>gempy</code> untuk pemodelan geologi, dan <code>gempy_viewer</code> untuk visualisasi.</li> <li>Mengatur tema plot PyVista ke <code>'document'</code> untuk tampilan bersih bergaya publikasi.</li> </ul> <p>Output: Mencetak <code>\"Setting Backend To: AvailableBackends.PYTORCH\"</code>.</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-2-memuat-dan-menampilkan-data","title":"Blok 2: Memuat dan Menampilkan Data","text":"<p><pre><code># Memuat data Anda\ncollar = pd.read_csv('collar.csv')  # hole_id, y, x, z\nsurvey = pd.read_csv('survey.csv')  # hole_id, dip, azimuth, depth\nlithology = pd.read_csv('lithology.csv')  # hole_id, from_depth, to_depth, lithology\nassay = pd.read_csv('assay.csv')  # hole_id, from_depth, to_depth, nickel_grade\n\nprint(collar.head(), survey.head(), lithology.head(), assay.head())\n</code></pre> Tujuan: Memuat data drill hole dari file CSV dan menampilkan lima baris pertama dari setiap dataset.</p> <p>Langkah-langkah:</p> <ul> <li> <p>Memuat empat dataset:</p> <ul> <li><code>collar</code>: Lokasi collar drill hole (BHID, XCOLLAR, YCOLLAR, ZCOLLAR).</li> <li><code>survey</code>: Data survei drill hole (BHID, DEPTH, AZIMUTH, DIP).</li> <li><code>lithology</code>: Interval litologi (BHID, Fr., To, LITOLOGI).</li> <li><code>assay</code>: Data assay dengan kadar nikel (BHID, Fr., To, Total Ni, dll.).</li> </ul> </li> <li> <p>Menggunakan <code>head()</code> dari <code>pandas</code> untuk melihat pratinjau data.</p> </li> </ul> <p>Output: Menampilkan contoh baris dari setiap DataFrame, menunjukkan ID drill hole, koordinat, kedalaman, kemiringan, azimuth, litologi (misalnya LIM), dan nilai assay (misalnya kadar nikel).</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-3-mengganti-nama-kolom","title":"Blok 3: Mengganti Nama Kolom","text":"<p><pre><code>collar = collar.rename(columns={'BHID': 'hole_id', 'YCOLLAR': 'y', 'XCOLLAR': 'x', 'ZCOLLAR': 'z'})\nsurvey = survey.rename(columns={'BHID': 'hole_id', 'DIP ': 'dip', 'AZIMUTH': 'azimuth', 'DEPTH': 'depth'})\nlithology = lithology.rename(columns={'BHID': 'hole_id', 'Fr.': 'from_depth', 'To': 'to_depth', 'LITOLOGI': 'lithology'})\nassay = assay.rename(columns={'BHID': 'hole_id', 'Fr.': 'from_depth', 'To': 'to_depth', 'Total Ni': 'nickel_grade'})\n\nprint(collar.head(), survey.head(), lithology.head(), assay.head())\n</code></pre> Tujuan: Menstandarkan nama kolom untuk konsistensi dan kompatibilitas dengan GemPy.</p> <p>Langkah-langkah:</p> <ul> <li>Mengganti nama kolom di setiap DataFrame menjadi nama yang konsisten dan deskriptif (misalnya, <code>BHID</code> \u2192 <code>hole_id</code>, <code>XCOLLAR</code> \u2192 <code>x</code>).</li> <li>Mencetak DataFrame yang diperbarui untuk memastikan perubahan.</li> </ul> <p>Output: Sama seperti Blok 2, tetapi dengan nama kolom yang diperbarui (misalnya, <code>hole_id</code>, <code>x</code>, <code>y</code>, <code>z</code>, dll.).</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-4-desurvey-drill-hole","title":"Blok 4: Desurvey drill hole","text":"<p>Blok ini panjang, jadi saya akan membaginya menjadi dua bagian untuk kejelasan.</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#bagian-41-mendefinisikan-fungsi-desurvey","title":"Bagian 4.1: Mendefinisikan Fungsi Desurvey","text":"<p><pre><code>def desurvey(hole_collar, hole_survey, depth_interval=1):\n    hole_survey = hole_survey.sort_values('depth')\n    depths = hole_survey['depth'].values\n    dips = hole_survey['dip'].values\n    azimuths = hole_survey['azimuth'].values\n    current_x = hole_collar['x'].iloc[0]\n    current_y = hole_collar['y'].iloc[0]\n    current_z = hole_collar['z'].iloc[0]\n    desurveyed_points = []\n\n    for i in range(len(depths)):\n        if i == 0:\n            start_depth = 0\n            end_depth = depths[0]\n            start_dip = 0\n            start_azimuth = 0\n            end_dip = dips[0]\n            end_azimuth = azimuths[0]\n        else:\n            start_depth = depths[i-1]\n            end_depth = depths[i]\n            start_dip = dips[i-1]\n            start_azimuth = azimuths[i-1]\n            end_dip = dips[i]\n            end_azimuth = azimuths[i]\n\n        avg_dip = (start_dip + end_dip) / 2\n        avg_azimuth = (start_azimuth + end_azimuth) / 2\n        delta_d = end_depth - start_depth\n        if delta_d &lt;= 0:\n            continue\n        dip_rad = np.radians(avg_dip)\n        azimuth_rad = np.radians(avg_azimuth)\n        delta_z = -delta_d * np.cos(dip_rad)\n        delta_x = delta_d * np.sin(dip_rad) * np.cos(azimuth_rad)\n        delta_y = delta_d * np.sin(dip_rad) * np.sin(azimuth_rad)\n\n        num_points = int(np.ceil(delta_d / depth_interval))\n        for j in range(num_points + 1):\n            d = start_depth + j * depth_interval\n            if d &gt; end_depth:\n                d = end_depth\n            fraction = (d - start_depth) / delta_d if delta_d &gt; 0 else 0\n            x = current_x + fraction * delta_x\n            y = current_y + fraction * delta_y\n            z = current_z + fraction * delta_z\n            desurveyed_points.append({'depth': d, 'x': x, 'y': y, 'z': z})\n        current_x += delta_x current_y += delta_y\n        current_z += delta_z\n\n    return pd.DataFrame(desurveyed_points)\n</code></pre> Tujuan: Mendefinisikan fungsi untuk menghitung koordinat 3D di sepanjang jalur drill hole berdasarkan data survei (kemiringan, azimuth, kedalaman).</p> <p>Langkah-langkah:</p> <ul> <li>Mengambil <code>hole_collar</code> (titik awal) dan <code>hole_survey</code> (perubahan kemiringan, azimuth, kedalaman) sebagai masukan.</li> <li>Mengurutkan data survei berdasarkan kedalaman dan mengiterasi melalui segmen-segmen.</li> <li> <p>Untuk setiap segmen:</p> <ul> <li>Menghitung rata-rata kemiringan dan azimuth.</li> <li>Mengonversi ke radian dan menghitung offset 3D (<code>delta_x</code>, <code>delta_y</code>, <code>delta_z</code>) menggunakan trigonometri.</li> <li>Menginterpolasi titik pada interval 1 meter (<code>depth_interval=1</code>) antara kedalaman awal dan akhir.</li> </ul> </li> <li> <p>Mengembalikan DataFrame dengan titik-titik desurvey (<code>depth</code>, <code>x</code>, <code>y</code>, <code>z</code>).</p> </li> </ul>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#bagian-42-menerapkan-desurvey-ke-semua-drill-hole","title":"Bagian 4.2: Menerapkan Desurvey ke Semua drill hole","text":"<p><pre><code>survey_grouped = survey.groupby('hole_id')\ndesurveyed_dict = {}\nfor hole_id, hole_survey in survey_grouped:\n    hole_collar = collar[collar['hole_id'] == hole_id]\n    if hole_collar.empty:\n        continue\n    desurveyed = desurvey(hole_collar, hole_survey)\n    desurveyed['hole_id'] = hole_id\n    desurveyed_dict[hole_id] = desurveyed\ndesurveyed_df = pd.concat(desurveyed_dict.values(), ignore_index=True)\n</code></pre> Tujuan: Menerapkan fungsi desurvey ke semua drill hole dan menggabungkan hasilnya.</p> <p>Langkah-langkah:</p> <ul> <li>Mengelompokkan data survei berdasarkan <code>hole_id</code>.</li> <li>Untuk setiap drill hole:<ul> <li>Mengekstrak data collar-nya.</li> <li>Memanggil <code>desurvey</code> untuk menghitung titik-titik 3D.</li> <li>Menambahkan <code>hole_id</code> ke hasil dan menyimpannya dalam kamus.</li> </ul> </li> <li>Menggabungkan semua titik desurvey menjadi satu DataFrame (<code>desurveyed_df</code>).</li> </ul> <p>Output: Tidak ada Output langsung; menghasilkan <code>desurveyed_df</code> dengan koordinat 3D untuk semua drill hole.</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-5-memproses-litologi","title":"Blok 5: Memproses Litologi","text":"<p>Blok ini juga panjang, jadi saya akan membaginya menjadi beberapa bagian.</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#bagian-51-mendefinisikan-fungsi-pengolahan-litologi","title":"Bagian 5.1: Mendefinisikan Fungsi pengolahan Litologi","text":"<p><pre><code># Mendefinisikan urutan stratigrafi\nstrat_order = {'LIM': 0, 'SAP': 1, 'BZ': 2}\n\ndef process_lithology(hole_lithology):\n    hole_lithology = hole_lithology.sort_values('from_depth')\n    processed = []\n    current_lith = None\n    current_from = None\n    current_thickness = 0\n\n    for i, row in hole_lithology.iterrows():\n        lith = row['lithology']\n        from_depth = row['from_depth']\n        to_depth = row['to_depth']\n        thickness = to_depth - from_depth\n\n        if current_lith is None:\n            current_lith = lith\n            current_from = from_depth\n            current_thickness = thickness\n        elif strat_order.get(lith, 999) &lt; strat_order.get(current_lith, 999):  # Tidak sesuai urutan\n            if thickness &lt; current_thickness:\n                continue\n            else:\n                processed.append({'from_depth': current_from, 'to_depth': from_depth, 'lithology': current_lith})\n                current_lith = lith\n                current_from = from_depth\n                current_thickness = thickness\n        else:\n            if lith == current_lith:\n                current_thickness += thickness\n            else:\n                processed.append({'from_depth': current_from, 'to_depth': from_depth, 'lithology': current_lith})\n                current_lith = lith\n                current_from = from_depth\n                current_thickness = thickness\n\n    if current_lith:\n        processed.append({'from_depth': current_from, 'to_depth': to_depth, 'lithology': current_lith})\n\n    if not any(p['lithology'] == 'Basement' for p in processed):\n        last_to = processed[-1]['to_depth']\n        processed.append({'from_depth': last_to, 'to_depth': last_to + 1, 'lithology': 'Basement'})\n\n    return pd.DataFrame(processed)\n</code></pre> Tujuan: Memproses interval litologi untuk memastikan urutan stratigrafi dan menggabungkan unit yang sama secara berurutan.</p> <p>Langkah-langkah:</p> <ul> <li>Mendefinisikan <code>strat_order</code> (LIM \u2192 SAP \u2192 BZ).</li> <li>Mengurutkan data litologi berdasarkan kedalaman.</li> <li> <p>Mengiterasi melalui interval:</p> <ul> <li>Menggabungkan interval berturut-turut dengan litologi yang sama.</li> <li>Menyelesaikan unit yang tidak sesuai urutan (misalnya SAP di atas LIM) dengan mempertahankan unit yang lebih tebal.</li> <li>Menambahkan lapisan tipis \u201cBasement\u201d di bagian bawah jika tidak ada.</li> </ul> </li> <li> <p>Mengembalikan DataFrame dengan interval yang diproses.</p> </li> </ul>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#bagian-52-menerapkan-pengolahan-dan-menyiapkan-titik-permukaan","title":"Bagian 5.2: Menerapkan pengolahan dan Menyiapkan Titik Permukaan","text":"<p><pre><code># Menerapkan ke semua lubang\nlithology_grouped = lithology.groupby('hole_id')\nprocessed_lithology = pd.concat([process_lithology(group) for _, group in lithology_grouped], \n                                keys=lithology_grouped.groups.keys()).reset_index(level=0).rename(columns={'level_0': 'hole_id'})\n\n# Menyiapkan titik permukaan dan mengekstrak bagian atas LIM untuk topografi\nsurface_points = []\nlim_top_points = []  # Untuk topografi\nfor hole_id, hole_lithology in processed_lithology.groupby('hole_id'):\n    if hole_id not in desurveyed_dict:\n        continue\n    hole_desurveyed = desurveyed_dict[hole_id]\n    depth_to_coords = dict(zip(hole_desurveyed['depth'], hole_desurveyed[['x', 'y', 'z']].to_numpy()))\n\n    lim_found = False\n    for _, row in hole_lithology.iterrows():\n        from_depth = row['from_depth']\n        from_coords = depth_to_coords.get(from_depth)\n        if from_coords is not None:\n            surface_points.append({\n                'x': from_coords[0],\n                'y': from_coords[1],\n                'z': from_coords[2],\n                'formation': row['lithology']\n            })\n            # Menangkap bagian atas LIM\n            if row['lithology'] == 'LIM' and not lim_found:\n                lim_top_points.append({\n                    'x': from_coords[0],\n                    'y': from_coords[1],\n                    'z': from_coords[2]\n                })\n                lim_found = True  # Hanya mengambil LIM paling atas\n\npoints_df = pd.DataFrame(surface_points)\nlim_top_df = pd.DataFrame(lim_top_points)\n</code></pre> Tujuan: Menerapkan pengolahan litologi ke semua drill hole dan menyiapkan titik permukaan untuk pemodelan.</p> <p>Langkah-langkah:</p> <ul> <li>Mengelompokkan litologi berdasarkan <code>hole_id</code> dan memproses setiap kelompok.</li> <li>Menggabungkan hasil menjadi <code>processed_lithology</code>.</li> <li>Memetakan koordinat desurvey ke kedalaman litologi.</li> <li> <p>Membuat:</p> <ul> <li><code>surface_points</code>: Semua batas litologi dengan koordinat 3D.</li> <li><code>lim_top_points</code>: Titik-titik paling atas LIM untuk topografi.</li> </ul> </li> <li> <p>Mengonversi ke DataFrame (<code>points_df</code>, <code>lim_top_df</code>).</p> </li> </ul>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-6-menginisialisasi-model-geologi","title":"Blok 6: Menginisialisasi Model Geologi","text":"<p><pre><code>all_x = points_df['x'].values\nall_y = points_df['y'].values\nall_z = points_df['z'].values\n\nextent = [\n    np.min(all_x) - 5, np.max(all_x) + 5,\n    np.min(all_y) - 5, np.max(all_y) + 5,\n    np.min(all_z) - 10, np.max(all_z) + 10\n]\n\ngeo_model = gp.create_geomodel(\n    project_name='Nickel_Mine_Model',\n    extent=extent,\n    resolution=[20, 20, 20],\n    structural_frame=gp.data.StructuralFrame.initialize_default_structure()\n)\n\n# Mengatur bagian atas LIM sebagai topografi menggunakan set_topography_from_arrays\ntopography_points = lim_top_df[['x', 'y', 'z']].to_numpy()\ngp.set_topography_from_arrays(\n    grid=geo_model.grid,\n    xyz_vertices=topography_points  # Mengirimkan array penuh (n, 3)\n)\n\nprint(\"Grid aktif:\", geo_model.grid.active_grids)\n</code></pre> Tujuan: Mengatur model geologi GemPy dengan luas dan topografi.</p> <p>Langkah-langkah:</p> <ul> <li>Menentukan luas model berdasarkan koordinat minimum/maksimum dengan tambahan ruang.</li> <li>Membuat <code>geo_model</code> dengan resolusi grid 20x20x20.</li> <li>Menggunakan bagian atas LIM untuk menentukan topografi.</li> <li>Mencetak grid aktif (misalnya, DENSE, TOPOGRAPHY).</li> </ul> <p>Output: <code>\"Grid aktif: GridTypes.DENSE|TOPOGRAPHY|NONE\"</code>.</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-7-mendefinisikan-elemen-struktural","title":"Blok 7: Mendefinisikan Elemen Struktural","text":"<p><pre><code>unique_lithologies = ['LIM', 'SAP', 'BZ']  # Menyertakan Basement secara eksplisit\ncolors = ['#33ABFF', '#FFA833', '#72A533']\n\nelements = []\nfor i, lith in enumerate(unique_lithologies):\n    lith_points = points_df[points_df['formation'] == lith]\n    if lith_points.empty:\n        continue\n    element = gp.data.StructuralElement(\n        name=lith,\n        color=colors[i],\n        surface_points=gp.data.SurfacePointsTable.from_arrays(\n            x=lith_points['x'].values,\n            y=lith_points['y'].values,\n            z=lith_points['z'].values,\n            names=lith\n        ),\n        orientations=gp.data.OrientationsTable.initialize_empty()\n    )\n    elements.append(element)\n\ngeo_model.structural_frame.structural_groups[0].elements = elements\ngeo_model.structural_frame.structural_groups[0].name = 'Stratigraphic_Series'\n</code></pre> Tujuan: Menentukan lapisan stratigrafi (LIM, SAP, BZ) untuk model.</p> <p>Langkah-langkah:</p> <ul> <li>Menetapkan warna untuk setiap litologi.</li> <li>Membuat objek <code>StructuralElement</code> dengan titik permukaan untuk setiap litologi.</li> <li>Menambahkan elemen ke kerangka struktural model sebagai seri stratigrafi.</li> </ul>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-8-menambahkan-orientasi","title":"Blok 8: Menambahkan Orientasi","text":"<p><pre><code>centroid_x = points_df['x'].mean()\ncentroid_y = points_df['y'].mean()\ncentroid_z = points_df['z'].mean()\n\ngp.add_orientations(\n    geo_model=geo_model,\n    x=[centroid_x],\n    y=[centroid_y],\n    z=[centroid_z],\n    elements_names=[elements[0].name],  # LIM\n    pole_vector=[np.array([0, 0, 1])]\n)\n</code></pre> Tujuan: Menambahkan satu orientasi untuk mengasumsikan lapisan datar.</p> <p>Langkah-langkah:</p> <ul> <li>Menghitung centroid dari semua titik permukaan.</li> <li>Menambahkan orientasi di centroid untuk LIM dengan vektor kutub vertikal (lapisan datar).</li> </ul>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-9-menonaktifkan-anisotropi","title":"Blok 9: Menonaktifkan Anisotropi","text":"<p><pre><code>geo_model.update_transform(gp.data.GlobalAnisotropy.NONE)\n</code></pre> Tujuan: Menyederhanakan model dengan menonaktifkan anisotropi global (mengasumsikan perilaku lapisan seragam).</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-10-menghitung-model","title":"Blok 10: Menghitung Model","text":"<p><pre><code>gp.compute_model(geo_model, engine_config=gp.data.GemPyEngineConfig(dtype='float64'))\n</code></pre> Tujuan: Menjalankan interpolasi geologi untuk menghitung model 3D.</p> <p>Langkah-langkah:</p> <ul> <li>Menggunakan PyTorch dengan presisi 64-bit untuk perhitungan.</li> </ul> <p>Output: <code>\"Solusi: 4 Tingkat Octree, 3 Mesh DualContouring\"</code>.</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-11-visualisasi-2d","title":"Blok 11: Visualisasi 2D","text":"<p><pre><code>gpv.plot_2d(geo_model, cell_number='mid', direction='y', show_data=False, show_results=True)\n</code></pre> Tujuan: Memplot penampang 2D melalui tengah model sepanjang sumbu Y.</p> <p>Langkah-langkah:</p> <ul> <li>Memvisualisasikan model yang dihitung tanpa titik data mentah.</li> </ul> <p>Output: Menampilkan plot 2D (gambar disertakan dalam notebook).</p> <p>Output: </p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-12-visualisasi-3d","title":"Blok 12: Visualisasi 3D","text":"<p><pre><code>plotter = gpv.plot_3d(\n    geo_model,\n    show_surfaces=True,\n    show_topography=True,\n    image=False,\n    plotter_type='basic',  # Lebih sederhana untuk performa\n    kwargs_plot_structured_grid={'opacity': 0.8, 'lighting': True}\n)\n</code></pre> Tujuan: Membuat visualisasi 3D dari model.</p> <p>Langkah-langkah:</p> <ul> <li>Menampilkan permukaan litologi dan topografi dengan opasitas 80% dan efek pencahayaan.</li> <li>Menggunakan plotter dasar untuk performa.</li> </ul> <p>Output: </p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#ringkasan","title":"Ringkasan","text":"<p>Panduan ini megolah data drill hole untuk memvisualisasikan model geologi 3D dari data pertambangan nikel laterit. Langkah-langkah meliputi:</p> <ol> <li>Memuat dan menyiapkan data.</li> <li>Melakukan desurvey drill hole untuk mendapatkan koordinat 3D.</li> <li>Memproses litologi untuk memastikan urutan stratigrafi.</li> <li>Mengatur model GemPy dengan topografi dan elemen struktural.</li> <li>Menghitung dan memvisualisasikan model dalam 2D dan 3D.</li> </ol>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/","title":"DrillHole Data Automation","text":""},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#modul-automasi-pengolahan-database-pengeboran","title":"Modul: Automasi pengolahan database pengeboran","text":"<p>Developed by: Hamba ALLAH</p> <p>For further colaborations, feel free to reach me out with Hyperlink above</p>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#sekapur-sirih","title":"Sekapur Sirih","text":"<p>Modul ini diharapkan dapat membantu dalam pembuatan automasi database dengan meng-update data harian secara automatis (contoh kasus dalam modul ini menggunakan data pengeboran yang akan terus diupdate berdasarkan data titik bor yang finish). Semoga bermanfaat dan membawa kebaikan.</p>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#panduan-step-by-steps","title":"Panduan Step by Steps","text":""},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#langkah-1-menyiapkan-environment-tools","title":"Langkah 1: Menyiapkan Environment Tools","text":"<p>1. Install Python:</p> <ul> <li>Unduh dan install Python 3.11 atau lebih baru dari situs resmi Python.</li> <li>Saat instalasi, pastikan opsi \u201cTambahkan Python ke PATH\u201d dicentang untuk akses baris perintah.</li> <li>Verifikasi instalasi dengan membuka Command Prompt (Windows) atau Terminal (Mac/Linux) dan ketik <code>python --version</code>.</li> </ul> <p>2. Buat Folder Proyek:</p> <ul> <li>Buat folder bernama <code>DrillHole_Automation</code> di komputer Anda (misalnya, <code>C:\\Users\\NamaPenggunaAnda\\DrillHole_Automation</code>).</li> <li>Di dalamnya, buat subfolder <code>Daily_Data</code> untuk file data harian yang akan ditambahkan ke database.</li> </ul> <p>3. Install Library yang Diperlukan:</p> <ul> <li>Buka Command Prompt, navigasikan ke <code>DrillHole_Automation</code> (misalnya, <code>cd C:\\Users\\NamaPenggunaAnda\\DrillHole_Automation</code>), dan jalankan perintah dibawah:      <pre><code>pip install flask watchdog openpyxl pandas matplotlib\n</code></pre></li> <li>Perintah diatas menginstal library Flask (server web), Watchdog (pemantauan file), OpenPyXL (penanganan Excel), Pandas (manipulasi data), dan Matplotlib (visualisasi).</li> </ul> <p>4. Siapkan File database Anda:</p> <ul> <li>Siapkan format database, e.g: <code>drilling_database.xlsx</code> dalam folder <code>DrillHole_Automation</code> dengan format disesuaikan dengan format database yang dibutuhkan (misalnya, <code>Date Logging</code>, <code>Hole ID</code>, <code>From</code>, dll.).</li> <li>Pastikan file dapat diedit dan tidak dibuka di Excel selama eksekusi skrip.</li> </ul> <p>5. Siapkan File Data Harian:</p> <ul> <li>Letakkan file Excel harian sampel (misalnya, <code>daily-data.xlsx</code>) di <code>Daily_Data</code>. File ini harus mengikuti format konsisten dengan metadata (e.g: Nama titi bor sel B2, Tanggal di sel J3).</li> </ul>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#langkah-2-buat-skrip-utama-data_updaterpy","title":"Langkah 2: Buat Skrip Utama (<code>data_updater.py</code>)","text":"<p>Buat file bernama <code>data_updater.py</code> di <code>DrillHole_Automation</code>. Script kode pada bagian ini akan kami bagi menjadi beberapa bagian yang akan membantu memudahkan dalam memahami format kode. </p>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#bagian-1-impor-dan-konfigurasi","title":"Bagian 1: Impor dan Konfigurasi","text":"<p>Tujuan: Menyiapkan library yang diperlukan.</p> <p><pre><code>import matplotlib\nmatplotlib.use('Agg')  # Gunakan backend non-GUI untuk Matplotlib untuk menghindari masalah threading\n\nimport time\nfrom watchdog.observers import Observer\nfrom watchdog.events import FileSystemEventHandler\nfrom flask import Flask, request, render_template_string\nimport openpyxl\nimport threading\nimport os\nimport pandas as pd\nimport logging\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\nfrom io import BytesIO\nimport base64\n\n# Siapkan logging untuk debugging dan pelacakan\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Konfigurasi\ndaily_folder = r'Daily_Data'\ndatabase_file = r'C:\\Users\\NamaPenggunaAnda\\DrillHole_Automation\\drilling_database.xlsx'\n</code></pre> Penjelasan:</p> <ul> <li><code>matplotlib.use('Agg')</code> mencegah error terkait GUI (misalnya, konflik dengan Tkinter) dengan menggunakan backend non-interaktif.</li> <li>Flask digunakan untuk menampilkan data bebasis dashboard, pemantauan file (Watchdog), manipulasi Excel (OpenPyXL), analisis data (Pandas), dan visualisasi (Matplotlib).</li> <li>Logging melacak operasi untuk debugging.</li> <li><code>daily_folder</code> dan <code>database_file</code> menentukan jalur file (sesuaikan <code>NamaPenggunaAnda</code> dengan nama pengguna Windows Anda atau gunakan <code>os.path.expanduser</code> untuk kompatibilitas lintas platform, misalnya, <code>os.path.expanduser('~') + '/DrillHole_Automation/drilling_database.xlsx'</code>).</li> </ul> <p>Potensi eror:</p> <p>Masalah penempatan folder: Jika jalur <code>daily_folder</code> atau <code>database_file</code> tidak sesuai, Anda akan mendapatkan <code>FileNotFoundError</code>. Verifikasi jalur di File Explorer dan sesuaikan.</p> <p>Error Instalasi Library: Potensi <code>pip install</code> gagal, pastikan ada akses internet atau periksa kompatibilitas versi Python.</p>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#bagian-2-pemantauan-sistem-file-dengan-watchdog","title":"Bagian 2: Pemantauan Sistem File dengan Watchdog","text":"<p>Tujuan: Mendeteksi folder <code>Daily_Data</code> untuk mendeteksi file Excel baru dan melakukan pemrosesan.</p> <p><pre><code>class Watcher:\n    def __init__(self):\n        self.observer = Observer()\n\n    def run(self):\n        event_handler = Handler()\n        self.observer.schedule(event_handler, daily_folder, recursive=False)\n        self.observer.start()\n        try:\n            while True:\n                time.sleep(1)\n        except KeyboardInterrupt:\n            self.observer.stop()\n        self.observer.join()\n\nclass Handler(FileSystemEventHandler):\n    def on_created(self, event):\n        if event.is_directory:\n            return\n        if event.src_path.endswith('.xls') atau event.src_path.endswith('.xlsx'):\n            logger.info(f\"File baru terdeteksi: {event.src_path}\")\n            try:\n                process_new_file(event.src_path)\n                logger.info(f\"Berhasil memproses file: {event.src_path}\")\n            except Exception as e:\n                logger.error(f\"Error memproses file {event.src_path}: {str(e)}\")\n</code></pre> Penjelasan:</p> <ul> <li><code>Watcher</code> membuat <code>Observer</code> untuk memantau <code>daily_folder</code> secara continue.</li> <li><code>Handler</code> memantau pembuatan file, memfilter file <code>.xls</code> atau <code>.xlsx</code>, dan menjalankan <code>process_new_file</code> untuk mengolah file baru.</li> <li><code>time.sleep(1)</code> mencegah overload CPU; <code>KeyboardInterrupt</code> menutup sistem ketika mengalami overload or stuck.</li> </ul> <p>Kemungkinan Eror:</p> <p>Izin Ditolak: Jika <code>Daily_Data</code> tidak memiliki izin baca/tulis, <code>Watchdog</code> gagal. Periksa izin folder di Windows Explorer.</p> <p>Penguncian File: Jika file dibuka di Excel, <code>Watchdog</code> mungkin memicu sebelum file sepenuhnya diedit, menyebabkan <code>PermissionError</code>. Tambahkan <code>time.sleep(2)</code> di <code>process_new_file</code> untuk menunda pemrosesan.</p>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#bagian-3-fungsi-pemrosesan-data","title":"Bagian 3: Fungsi Pemrosesan Data","text":"<p>Tujuan: Menganalisis, memindahkan, dan memperbarui data harian ke dalam database.</p> <p><pre><code>def process_new_file(file_path):\n    time.sleep(2)  # Pastikan file sepenuhnya ditulis\n    transformed_data = transform_data(file_path)\n    append_to_database(transformed_data)\n\ndef transform_data(file_path):\n    try:\n        wb = openpyxl.load_workbook(file_path, data_only=True)\n        sheet = wb.active\n\n        raw_hole_id = sheet['B2'].value\n        raw_date_logging = sheet['J3'].value\n        logger.info(f\"Metadata mentah dari {os.path.basename(file_path)} - B2: {raw_hole_id}, J3: {raw_date_logging}\")\n\n        hole_id = str(raw_hole_id).strip() if raw_hole_id else None\n        date_logging = raw_date_logging\n        if isinstance(date_logging, datetime):\n            date_logging = date_logging.date()\n        elif isinstance(date_logging, str):\n            try:\n                date_logging = datetime.strptime(date_logging, '%Y-%m-%d %H:%M:%S').date()\n            except ValueError:\n                date_logging = None\n\n        if not hole_id or not date_logging:\n            raise ValueError(f\"Missing or invalid Hole ID ({hole_id}) or Date Logging ({date_logging}) in metadata\")\n\n        daily_data = pd.read_excel(file_path, skiprows=7, header=0, usecols='B:V')\n        logger.info(f\"Kolom di {os.path.basename(file_path)}: {list(daily_data.columns)}\")\n\n        # Data kolom disesuaikan dengan format database yang dibuat atau dimiliki.\n        required_columns = ['FROM', 'TO', 'INTERVAL (M)', 'ACT CORE (M)', 'RECOVERY (%)',\n                           'GENERAL LITHOLOGY', 'SUB GEN LITHOLOGY', 'ROCK CODE', 'GRAIN SIZE',\n                           'WEATHERING', 'COLOUR', 'PRIMARY.1', 'SECONDARY.1', 'TERTIARY']\n        missing_columns = [col for col in required_columns if col not in daily_data.columns]\n        if missing_columns:\n            logger.warning(f\"Kolom yang diharapkan hilang: {missing_columns}. Kembali ke indeks.\")\n            daily_data = pd.read_excel(file_path, skiprows=8, header=None, usecols='B:V')\n            transformed_rows = []\n            for _, row in daily_data.iterrows():\n                if pd.isna(row[0]):\n                    continue\n                transformed_row = {\n                    'Date Logging': date_logging,\n                    'Hole ID': hole_id,\n                    'From': row[0],\n                    'To': row[1],\n                    'Length': row[2],\n                    'Actual Core': row[3],\n                    'Recovery pecentage': row[6] / 100 if pd.notna(row[6]) else 1.0,\n                    'Material Code': str(row[7]).lower() if pd.notna(row[7]) else '',\n                    'Layer Code': str(row[8]).lower() if pd.notna(row[8]) else '',\n                    'Rock Code': str(row[9]).lower() if pd.notna(row[9]) else '',\n                    'Grain': str(row[10]).lower() if pd.notna(row[10]) else '',\n                    'Weath': row[12] if pd.notna(row[12]) else None,\n                    'Colour': str(row[13]).lower() if pd.notna(row[13]) else '',\n                    'Minerals Pri': str(row[16]).lower() if pd.notna(row[16]) else '',\n                    'Minerals Sec': str(row[17]).lower() if pd.notna(row[17]) else '',\n                    'Minerals Ter': str(row[18]).lower() if pd.notna(row[18]) else '',\n                    'Bolder leght (m)': None\n                }\n                transformed_rows.append(transformed_row)\n        else:\n            transformed_rows = []\n            for _, row in daily_data.iterrows():\n                if pd.isna(row['FROM']):\n                    continue\n                transformed_row = {\n                    'Date Logging': date_logging,\n                    'Hole ID': hole_id,\n                    'From': row['FROM'],\n                    'To': row['TO'],\n                    'Length': row['INTERVAL (M)'],\n                    'Actual Core': row['ACT CORE (M)'],\n                    'Recovery pecentage': row['RECOVERY (%)'] / 100 if pd.notna(row['RECOVERY (%)']) else 1.0,\n                    'Material Code': str(row['GENERAL LITHOLOGY']).lower() if pd.notna(row['GENERAL LITHOLOGY']) else '',\n                    'Layer Code': str(row['SUB GEN LITHOLOGY']).lower() if pd.notna(row['SUB GEN LITHOLOGY']) else '',\n                    'Rock Code': str(row['ROCK CODE']).lower() if pd.notna(row['ROCK CODE']) else '',\n                    'Grain': str(row['GRAIN SIZE']).lower() if pd.notna(row['GRAIN SIZE']) else '',\n                    'Weath': row['WEATHERING'] if pd.notna(row['WEATHERING']) else None,\n                    'Colour': str(row['COLOUR']).lower() if pd.notna(row['COLOUR']) else '',\n                    'Minerals Pri': str(row['PRIMARY.1']).lower() if pd.notna(row['PRIMARY.1']) else '',\n                    'Minerals Sec': str(row['SECONDARY.1']).lower() if pd.notna(row['SECONDARY.1']) else '',\n                    'Minerals Ter': str(row['TERTIARY']).lower() if pd.notna(row['TERTIARY']) else '',\n                    'Bolder leght (m)': None\n                }\n                transformed_rows.append(transformed_row)\n        return transformed_rows\n    except Exception as e:\n        logger.error(f\"Error di transform_data: {str(e)}\")\n        raise\n\ndef append_to_database(transformed_rows):\n    try:\n        db_path = os.path.normpath(database_file)\n        logger.info(f\"Mencoba memperbarui database di: {db_path}\")\n\n        wb = openpyxl.load_workbook(db_path)\n        sheet = wb.active\n        last_row = sheet.max_row\n\n        if last_row == 1 and sheet.cell(row=1, column=1).value is None:\n            headers = ['Date Logging', 'Hole ID', 'From', 'To', 'Length', 'Actual Core', 'Recovery pecentage',\n                       'Material Code', 'Layer Code', 'Rock Code', 'Grain', 'Weath', 'Colour',\n                       'Minerals Pri', 'Minerals Sec', 'Minerals Ter', 'Bolder leght (m)']\n            for col, header in enumerate(headers, 1):\n                sheet.cell(row=1, column=col).value = header\n            last_row = 1\n\n        for row_data in transformed_rows:\n            last_row += 1\n            sheet.cell(row=last_row, column=1).value = row_data['Date Logging']\n            sheet.cell(row=last_row, column=2).value = row_data['Hole ID']\n            sheet.cell(row=last_row, column=3).value = row_data['From']\n            sheet.cell(row=last_row, column=4).value = row_data['To']\n            sheet.cell(row=last_row, column=5).value = row_data['Length']\n            sheet.cell(row=last_row, column=6).value = row_data['Actual Core']\n            sheet.cell(row=last_row, column=7).value = row_data['Recovery pecentage']\n            sheet.cell(row=last_row, column=8).value = row_data['Material Code']\n            sheet.cell(row=last_row, column=9).value = row_data['Layer Code']\n            sheet.cell(row=last_row, column=10).value = row_data['Rock Code']\n            sheet.cell(row=last_row, column=11).value = row_data['Grain']\n            sheet.cell(row=last_row, column=12).value = row_data['Weath']\n            sheet.cell(row=last_row, column=13).value = row_data['Colour']\n            sheet.cell(row=last_row, column=14).value = row_data['Minerals Pri']\n            sheet.cell(row=last_row, column=15).value = row_data['Minerals Sec']\n            sheet.cell(row=last_row, column=16).value = row_data['Minerals Ter']\n            sheet.cell(row=last_row, column=17).value = row_data['Bolder leght (m)']\n\n        wb.save(db_path)\n        logger.info(f\"Berhasil menambahkan {len(transformed_rows)} baris ke {db_path}\")\n    except Exception as e:\n        logger.error(f\"Error menambahkan ke database: {str(e)}\")\n        raise\n</code></pre> Penjelasan:</p> <ul> <li><code>process_new_file</code>: Mengkoordini pengolahan data dan memastikan ketersediaan file.</li> <li><code>transform_data</code>: Membaca metadata (ID Lubang, Tanggal), memvalidasinya, dan mentransformasi data harian ke format database, menangani ketidaksesuaian header dengan indeks sebagai cadangan.</li> <li><code>append_to_database</code>: Memperbarui <code>drilling_database.xlsx</code>, menambahkan header jika diperlukan, memastikan konsistensi data.</li> </ul> <p>Kemungkinan Eror:</p> <p>Error Metadata: Jika cell excel <code>B2</code> atau <code>J3</code> kosong, gunakan log untuk debugging dan buat ulang file jika rusak.</p> <p>Ketidaksesuaian Kolom: Jika header berbeda, log akan menunjukkan nama kolom; sesuaikan <code>transform_data</code> untuk indeks atau header.</p> <p>Izin File: Pastikan akses tulis ke <code>drilling_database.xlsx</code>, periksa melalui properti Windows Explorer.</p>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#bagian-4-menampilakan-data-dengan-dashboard-sederhana-dengan-flask","title":"Bagian 4: Menampilakan data dengan dashboard sederhana dengan <code>Flask</code>","text":"<p>Tujuan: Menyediakan dashboard di internal komputer untuk visualisasi dan pembaruan manual.</p> <p><pre><code>app = Flask(__name__)\n\ndef load_database():\n    return pd.read_excel(database_file)\n\ndef generate_recovery_plot(df):\n    depth_avg = df.groupby('From')['Recovery pecentage'].mean().reset_index()\n    plt.figure(figsize=(10, 6))\n    plt.plot(depth_avg['From'], depth_avg['Recovery pecentage'], marker='o', linestyle='-', color='biru')\n    plt.title('Persentase Pemulihan Rata-rata vs. Kedalaman Rata-rata')\n    plt.xlabel('Kedalaman Rata-rata (m) - Dari')\n    plt.ylabel('Persentase Pemulihan Rata-rata')\n    plt.grid(True)\n    img = BytesIO()\n    plt.savefig(img, format='png', bbox_inches='tight')\n    plt.close()\n    return base64.b64encode(img.getvalue()).decode('utf-8')\n\ndef generate_material_distribution_plot(df):\n    material_counts = df['Material Code'].value_counts()\n    plt.figure(figsize=(10, 6))\n    material_counts.plot(kind='bar', color='ungu')\n    plt.title('Distribusi Kode Material')\n    plt.xlabel('Kode Material')\n    plt.ylabel('Jumlah')\n    plt.xticks(rotation=45)\n    plt.grid(axis='y')\n    img = BytesIO()\n    plt.savefig(img, format='png', bbox_inches='tight')\n    plt.close()\n    return base64.b64encode(img.getvalue()).decode('utf-8')\n\nDASHBOARD_TEMPLATE = \"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Dashboard Analitik DrillHole&lt;/title&gt;\n    &lt;style&gt;\n        body { font-family: Arial, sans-serif; margin: 0; background-color: #f5f7fa; color: #333; }\n        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }\n        .sidebar { width: 200px; float: left; background-color: #e9ecef; padding: 20px; height: 100vh; position: fixed; }\n        .content { margin-left: 220px; }\n        h1 { text-align: center; color: #2c3e50; margin-bottom: 20px; }\n        .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-bottom: 20px; }\n        .stat-card { background-color: white; border-radius: 8px; padding: 15px; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n        .stat-card h3 { margin: 0 0 5px 0; font-size: 14px; color: #7f8c8d; }\n        .stat-card p { margin: 0; font-size: 18px; color: #2c3e50; }\n        .plot-section { background-color: white; border-radius: 8px; padding: 20px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n        .plot { text-align: center; }\n        img { max-width: 100%; height: auto; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"sidebar\"&gt;\n        &lt;h2&gt;Navigasi&lt;/h2&gt;\n        &lt;ul style=\"list-style-type: none; padding: 0;\"&gt;\n            &lt;li&gt;&lt;a href=\"/\" style=\"color: #2c3e50; text-decoration: none;\"&gt;Dashboard&lt;/a&gt;&lt;/li&gt;\n            &lt;li&gt;&lt;a href=\"/update\" style=\"color: #2c3e50; text-decoration: none;\"&gt;Perbarui Data&lt;/a&gt;&lt;/li&gt;\n            &lt;li&gt;&lt;a href=\"/database-status\" style=\"color: #2c3e50; text-decoration: none;\"&gt;Status database&lt;/a&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/div&gt;\n    &lt;div class=\"content\"&gt;\n        &lt;div class=\"container\"&gt;\n            &lt;h1&gt;Dashboard Analitik DrillHole&lt;/h1&gt;\n            &lt;div class=\"stats-grid\"&gt;\n                &lt;div class=\"stat-card\"&gt;\n                    &lt;h3&gt;Total Lubang Pengeboran&lt;/h3&gt;\n                    &lt;p&gt;{{ total_holes }}&lt;/p&gt;\n                &lt;/div&gt;\n                &lt;div class=\"stat-card\"&gt;\n                    &lt;h3&gt;Kedalaman Rata-rata&lt;/h3&gt;\n                    &lt;p&gt;{{ avg_depth|round(2) }} m&lt;/p&gt;\n                &lt;/div&gt;\n                &lt;div class=\"stat-card\"&gt;\n                    &lt;h3&gt;Kedalaman Terdalam&lt;/h3&gt;\n                    &lt;p&gt;{{ deepest_depth|round(2) }} m&lt;/p&gt;\n                &lt;/div&gt;\n                &lt;div class=\"stat-card\"&gt;\n                    &lt;h3&gt;Kedalaman Terpendek&lt;/h3&gt;\n                    &lt;p&gt;{{ shallowest_depth|round(2) }} m&lt;/p&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"plot-section\"&gt;\n                &lt;h2&gt;Persentase Pemulihan Rata-rata vs. Kedalaman Rata-rata&lt;/h2&gt;\n                &lt;div class=\"plot\"&gt;\n                    {% if recovery_plot %}\n                        &lt;img src=\"data:image/png;base64,{{ recovery_plot }}\" alt=\"Plot Pemulihan\"&gt;\n                    {% else %}\n                        &lt;p&gt;Tidak ada data yang tersedia.&lt;/p&gt;\n                    {% endif %}\n                &lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"plot-section\"&gt;\n                &lt;h2&gt;Distribusi Kode Material&lt;/h2&gt;\n                &lt;div class=\"plot\"&gt;\n                    &lt;img src=\"data:image/png;base64,{{ material_plot }}\" alt=\"Distribusi Material\"&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\n@app.route('/', methods=['GET'])\ndef dashboard():\n    try:\n        df = load_database()\n        total_holes = len(df['Hole ID'].unique()) if not df.empty else 0\n        avg_depth = df['Length'].mean() if not df.empty else 0\n        deepest_depth = df['To'].max() if not df.empty else 0\n        shallowest_depth = df['From'].min() if not df.empty else 0\n        recovery_plot = generate_recovery_plot(df)\n        material_plot = generate_material_distribution_plot(df)\n        return render_template_string(DASHBOARD_TEMPLATE, total_holes=total_holes, avg_depth=avg_depth,\n                                     deepest_depth=deepest_depth, shallowest_depth=shallowest_depth,\n                                     recovery_plot=recovery_plot, material_plot=material_plot)\n    except Exception as e:\n        logger.error(f\"Error merender dashboard: {str(e)}\")\n        return f\"Error: {str(e)}\", 500\n\n@app.route('/update', methods=['GET', 'POST'])\ndef trigger_update():\n    try:\n        processed_files = []\n        for file in os.scandir(daily_folder):\n            if file.is_file() and (file.name.endswith('.xls') or file.name.endswith('.xlsx')):\n                process_new_file(file.path)\n                processed_files.append(file.name)\n        return {'status': 'success', 'processed_files': processed_files, 'message': 'Pembaruan manual dipicu'}\n    except Exception as e:\n        return {'status': 'error', 'message': str(e)}, 500\n\n@app.route('/database-status', methods=['GET'])\ndef database_status():\n    try:\n        wb = openpyxl.load_workbook(database_file)\n        sheet = wb.active\n        return {'status': 'success', 'last_row': sheet.max_row}, 200\n    except Exception as e:\n        return {'status': 'error', 'message': str(e)}, 500\n</code></pre> Penjelasan:</p> <ul> <li><code>load_database</code>: Memuat database untuk analisis.</li> <li><code>generate_recovery_plot</code>, <code>generate_material_distribution_plot</code>: Membuat visualisasi, dideskripsikan sebagai base64 untuk dashboard.</li> <li><code>DASHBOARD_TEMPLATE</code>: HTML dengan CSS untuk menampilkan dashboard, meliputi statistik dan plot.</li> <li>Rute menangani tampilan dashboard, pembaruan manual, dan pemeriksaan status database.</li> </ul> <p>Kemungkinan Eror:</p> <p>Masalah Backend Matplotlib: Jika <code>matplotlib.use('Agg')</code> dilewatkan, expect error threading. Pastikan ada di awal skrip.</p> <p>Error Memuat database: Jika <code>drilling_database.xlsx</code> hilang atau salah format, <code>pd.read_excel</code> gagal. Verifikasi keberadaan dan format file.</p> <p>Error Rute Flask: Pastikan metode HTTP benar; sesuaikan jika terjadi error 405, seperti yang terlihat dengan <code>/update</code>.</p>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#bagian-5-menjalankan-sistem","title":"Bagian 5: Menjalankan Sistem","text":"<p>Tujuan: Jalankan skrip untuk memantau dan memperbarui data secara terus-menerus.</p> <p><pre><code>if __name__ == '__main__':\n    watcher_thread = threading.Thread(target=lambda: Watcher().run())\n    watcher_thread.daemon = True\n    watcher_thread.start()\n    app.run(host='127.0.0.1', port=5000)\n</code></pre> Penjelasan:</p> <ul> <li>Menjalankan <code>Watcher</code> untuk pemantauan file pada folder yang telah ditentukan sebelumnya.</li> <li>Meluncurkan Flask di <code>localhost:5000</code>, dapat diakses melalui browser untuk dashboard.</li> </ul> <p>Kemungkinan Eror: Konflik Port: Jika anda sedang menjalankan 5000 sebagai lokal host untuk projek lain maka Flask tidak dapat mengunakan host tersebut. Ubah ke <code>app.run(host='127.0.0.1', port=5001)</code> atau hapus poject yang bersangkutan.</p> <p>Masalah Threading: Jika <code>Watcher</code> atau Flask crash, periksa log untuk pengecualian, memastikan izin dan akses file yang tepat.</p>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#langkah-3-ujicoba-dan-penanganan-masalah","title":"Langkah 3: Ujicoba dan Penanganan Masalah","text":"<ol> <li> <p>Jalankan Skrip:</p> <ul> <li>Buka Command Prompt di <code>DrillHole_Automation</code>, ketik <code>python data_updater.py</code>, dan tekan Enter.</li> <li>Periksa log untuk konfirmasi (misalnya, <code>File baru terdeteksi</code>).</li> </ul> </li> <li> <p>Tambahkan File Uji:</p> <ul> <li>Salin <code>daily-data.xlsx</code> ke <code>Daily_Data</code> dan verifikasi pembaruan database, memeriksa log untuk keberhasilan atau error.</li> </ul> </li> <li> <p>Akses Dashboard:</p> <ul> <li>Buka browser di <code>http://127.0.0.1:5000</code> untuk melihat statistik dan plot.</li> <li>Gunakan tautan sidebar untuk menguji <code>/update</code> dan <code>/database-status</code>.</li> </ul> </li> <li> <p>Solusi:</p> <ul> <li>Masalah Metadata: Jika <code>Missing or invalid metadata</code>, buka <code>daily-data.xlsx</code>, pastikan <code>B2</code> dan <code>J3</code> memiliki data, dan log nilai mentah untuk debugging.</li> <li>Ketidaksesuaian Kolom: Jika <code>KeyError</code>, log <code>daily_data.columns</code> dan sesuaikan <code>transform_data</code> untuk indeks atau header.</li> <li>Error Matplotlib: Jika <code>RuntimeError</code>, pastikan <code>matplotlib.use('Agg')</code> ada di awal skrip.</li> <li>Error 405: Jika <code>/update</code> gagal, verifikasi eror tersebut dengan melihat GET di dashboard.</li> </ul> </li> </ol>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#penanganan-kesalahan-rinci-dan-solusi","title":"Penanganan Kesalahan Rinci dan Solusi","text":"Kesalahan Penyebab Solusi <code>FileNotFoundError</code> untuk <code>daily_folder</code> Jalur folder atau file salah Verifikasi jalur, gunakan <code>os.path.exists()</code> untuk memeriksa <code>PermissionError</code> untuk akses file File terkunci atau tidak ada izin Tutup Excel, periksa izin Windows <code>KeyError: 'FROM'</code> Header hilang atau salah nama di file harian Log kolom, gunakan indeks, pastikan format file <code>ValueError: Missing or invalid metadata</code> Sel <code>B2</code> atau <code>J3</code> kosong atau salah format Buka file, verifikasi data, log nilai mentah, buat ulang <code>RuntimeError: main thread not in main loop</code> Konflik backend Matplotlib Tkinter Gunakan <code>matplotlib.use('Agg')</code> di awal skrip <code>405 Method Not Allowed</code> untuk <code>/update</code> Permintaan GET ke rute POST-only Tambah <code>methods=['GET', 'POST']</code> ke rute <code>/update</code> <code>Port Already in Use</code> untuk Flask Port 5000 sedang digunakan Ubah ke port lain (misalnya, 5001)"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#kesimpulan","title":"Kesimpulan","text":"<p>Panduan ini diharapkan membantu Anda membuat, menguji, dan memelihara sistem automasi data pengeboran di lokal komputer, menangani kesalahan melalui logging dan penyesuaian dari format data harian ke format database. Sistem ini mengotomatisasi pembaruan, menyediakan dashboard untuk memantau data, dan beroperasi secara offline, ideal untuk lingkungan kerja lapangan yang terkendala akses internet.</p>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#peningkatan-potensial","title":"Peningkatan Potensial","text":"<ul> <li>Tambahkan validasi data untuk penanganan error yang lebih kuat.</li> <li>Gunakan Plotly untuk visualisasi interaktif di dashboard.</li> <li>Implementasikan cadangan terjadwal untuk <code>drilling_database.xlsx</code>.</li> </ul>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#referensi","title":"Referensi","text":"<ul> <li>Dokumentasi Resmi Flask</li> <li>Library Watchdog Python</li> <li>Dokumentasi OpenPyXL</li> <li>Dokumentasi Pandas</li> <li>Dokumentasi Matplotlib</li> </ul>"},{"location":"python/basics/Membuat%20Topo%20dari%20Data%20Koordinat/","title":"Membuat Topo dari Data Koordinat","text":"<p>Modul ini disusun untuk membantu dalam pengolahan data koordinat XYZ serta dapat diekspor kedalam format data GIS yang sering digunakan seperti <code>.shp</code> atau <code>.tiff</code>, berikut penjelasan yang cukup membingungkan dari salah satu AI yang memiliki akurasi model paling baik saat tulisan ini dibuat.</p> <p>Bayangkan Anda memiliki peta kertas tua yang berisi titik-titik ketinggian di sebuah bukit. Anda ingin mengubahnya menjadi peta 3D yang keren, seperti yang ada di film fiksi ilmiah, dan juga menyimpannya dalam format yang bisa dibaca oleh aplikasi peta modern seperti Google Earth. Sintaks dalam file <code>topo.ipynb</code> ini seperti asisten setia Anda: ia membaca data titik-titik ketinggian dari file CSV, membuat visualisasi 3D yang bisa dilihat dari berbagai sudut, dan menyimpan hasilnya dalam bentuk file yang bisa digunakan di perangkat lunak peta profesional. Singkatnya, Sintaks ini membantu Anda \"menghidupkan\" data topografi menjadi gambar dan file yang berguna!</p>"},{"location":"python/basics/Membuat%20Topo%20dari%20Data%20Koordinat/#penjelasan-sintaks-bagian-per-bagian","title":"Penjelasan Sintaks Bagian per Bagian","text":""},{"location":"python/basics/Membuat%20Topo%20dari%20Data%20Koordinat/#1-impor-library-yang-dibutuhkan","title":"1. Impor Library yang Dibutuhkan","text":"<p>Sintaks: <pre><code>import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\nimport pyvista as pv\nfrom scipy.interpolate import griddata\nimport rasterio\nfrom rasterio.transform import from_origin\nimport geopandas as gpd\nfrom shapely.geometry import LineString\n</code></pre></p> <p>Tujuan:</p> <p>Silahkan dibaca setiap bagian tujuan jika anda bisa memahami tujuan umum pada bagian awal, setiap penjelasan pada modul ini di generate menggunakan AI, jika menurut anda penjelasan tersebut tidak sesuai, silahkan fokus pada blok code dan bagaimana seharusnya luaran dari Sintaks tersebut.</p> <p>Ini seperti mengumpulkan semua alat yang Anda butuhkan sebelum memulai proyek seni. Misalnya, Anda membutuhkan pensil (pandas untuk membaca data), kalkulator (numpy untuk perhitungan), kanvas dan cat (matplotlib dan pyvista untuk menggambar), serta kotak penyimpanan khusus (rasterio dan geopandas untuk menyimpan hasil).</p> <p>Simmiliar Function:</p> <ul> <li>Untuk membaca data: Bayangkan Anda membaca daftar belanja dari kertas biasa (modul <code>csv</code>) atau dari spreadsheet Excel (modul <code>openpyxl</code>).</li> <li>Untuk interpolasi: Seperti menebak tinggi tanah di antara dua titik yang diketahui dengan kalkulator lain (<code>scipy.interpolate.interp2d</code> atau <code>numpy.interp</code>).</li> <li>Untuk visualisasi: Seperti menggunakan aplikasi desain interaktif (plotly) atau alat lukis 3D canggih (mayavi, vtk).</li> <li>Untuk menyimpan: Seperti menggunakan kotak arsip lain (fiona, gdal) atau mengedit foto sebelum menyimpan (PIL).</li> </ul> <p>Output:</p> <p>Tidak ada gambar atau file yang muncul di sini, hanya persiapan alat untuk langkah berikutnya.</p>"},{"location":"python/basics/Membuat%20Topo%20dari%20Data%20Koordinat/#2-mengimpor-data-dalam-modul-ini-menggunakan-data-csv","title":"2. Mengimpor Data (dalam modul ini menggunakan data .CSV)","text":"<p>Sintaks: <pre><code>data = pd.read_csv('topo_ex3.csv', header=None)\ndata.columns = ['X', 'Y', 'Z', 'I', 'J']\nx = data['X'].values\ny = data['Y'].values\nz = data['Z'].values\nprint(data.head())\n</code></pre></p> <p>Tujuan:</p> <p>Bayangkan Anda membuka buku catatan tua yang penuh dengan titik-titik koordinat X, Y, dan ketinggian Z dari sebuah bukit. Sintaks ini seperti asisten yang membaca buku itu, memberi label pada setiap kolom (X untuk posisi timur-barat, Y untuk utara-selatan, Z untuk ketinggian), dan menyiapkan datanya untuk Anda gunakan lebih lanjut.</p> <p>Simmiliar Function:</p> <ul> <li>Anda bisa membaca buku itu secara manual dengan tangan (modul <code>csv</code>) atau menggunakan alat sederhana untuk membaca file teks (numpy.loadtxt).</li> </ul> <p>Metode dan Fungsi lain yang dapat digunakan:</p> <p><pre><code># Menggunakan numpy.loadtxt\nimport numpy as np\ndata = np.loadtxt('topo_ex3.csv', delimiter=',')  # Asumsi tidak ada header\nx, y, z = data[:, 0], data[:, 1], data[:, 2]\nprint(data[:5])  # Tampilkan 5 baris pertama\n</code></pre> Output:</p> <p>Anda akan melihat daftar kecil dari data, seperti melihat 5 baris pertama dari buku catatan:   <pre><code>     X           Y        Z    I   J\n0  9628389.460  410687.142  290.976  NaN NaN\n1  9628491.658  410758.041  299.953  NaN NaN\n2  9628213.287  409755.982  164.825  NaN NaN\n3  9628213.287  409755.982  164.825  NaN NaN\n4  9628756.121  410610.314  230.739  NaN NaN\n</code></pre></p>"},{"location":"python/basics/Membuat%20Topo%20dari%20Data%20Koordinat/#3-visualisasi-3d-dengan-matplotlib","title":"3. Visualisasi 3D dengan Matplotlib","text":"<p>Sintaks: <pre><code>x, y, z = data[\"X\"], data[\"Y\"], data[\"Z\"]\ngrid_x, grid_y = np.meshgrid(\n    np.linspace(x.min(), x.max(), 100),\n    np.linspace(y.min(), y.max(), 100)\n)\ngrid_z = griddata((x, y), z, (grid_x, grid_y), method=\"cubic\")\nfig = plt.figure(figsize=(16, 12))\nax = fig.add_subplot(111, projection=\"3d\")\nax.plot_surface(grid_x, grid_y, grid_z, cmap=\"terrain\", edgecolor=\"none\")\nax.set_xlabel(\"X Coordinate\")\nax.set_ylabel(\"Y Coordinate\")\nax.set_zlabel(\"Elevation (Z)\")\nax.set_title(\"3D Topography Surface\")\nplt.show()\n</code></pre></p> <p>Tujuan:</p> <p>Ini seperti menggambar peta 3D sederhana dari bukit Anda di atas kertas. Sintaks ini mengambil titik-titik ketinggian, membuat \"jaring\" halus di antara titik-titik itu (seperti menarik garis halus di antara titik-titik), lalu menampilkan gambar 3D yang bisa Anda lihat di layar.</p> <p>Simmiliar Function:</p> <ul> <li>Anda bisa menggunakan aplikasi interaktif seperti peta digital di ponsel (plotly).</li> <li>Atau alat lukis 3D yang lebih canggih seperti di studio animasi (mayavi).</li> </ul> <p>Metode dan Fungsi lain yang dapat digunakan:</p> <p><pre><code># Menggunakan Plotly untuk visualisasi interaktif\nimport plotly.graph_objects as go\nfig = go.Figure(data=[go.Surface(z=grid_z, x=grid_x, y=grid_y)])\nfig.update_layout(title='Peta Bukit 3D', scene=dict(xaxis_title='X', yaxis_title='Y', zaxis_title='Ketinggian'))\nfig.show()\n</code></pre> Output:</p> <p>Anda akan melihat gambar peta 3D statis di layar, seperti lukisan bukit dengan warna yang menunjukkan ketinggian, lengkap dengan label sumbu X, Y, dan Z.</p> <p></p>"},{"location":"python/basics/Membuat%20Topo%20dari%20Data%20Koordinat/#4-visualisasi-3d-dengan-pyvista","title":"4. Visualisasi 3D dengan Pyvista","text":"<p>Sintaks: <pre><code>points = np.c_[data[\"X\"], data[\"Y\"], data[\"Z\"]]\npoint_cloud = pv.PolyData(points)\nsurf = point_cloud.delaunay_2d()\nsurf[\"Elevation\"] = surf.points[:, 2]\ncontours = surf.contour(isosurfaces=25)\nplotter = pv.Plotter()\nplotter.add_mesh(surf, cmap=\"terrain\", show_edges=False)\nplotter.add_mesh(contours, color=\"black\", line_width=1.5)\nplotter.show()\n</code></pre></p> <p>Tujuan:</p> <p>Bayangkan Anda membuat model bukit 3D dari plastisin yang bisa Anda putar dan lihat dari semua sudut, lengkap dengan garis-garis ketinggian seperti di peta topografi. Sintaks ini membuat visualisasi interaktif yang lebih hidup dibandingkan Matplotlib.</p> <p>Simmiliar Function:</p> <ul> <li>Anda bisa menggunakan alat 3D profesional seperti di studio film (vtk).</li> <li>Atau alat untuk membuat model 3D dari titik-titik (trimesh).</li> </ul> <p>Metode dan Fungsi lain yang dapat digunakan:</p> <p><pre><code># Menggunakan VTK (sederhana)\nimport vtk\npoints = vtk.vtkPoints()\nfor i in range(len(x)):\n    points.InsertNextPoint(x[i], y[i], z[i])\npolydata = vtk.vtkPolyData()\npolydata.SetPoints(points)\ndelaunay = vtk.vtkDelaunay2D()\ndelaunay.SetInputData(polydata)\ndelaunay.Update()\n# Tambahkan Sintaks visualisasi lebih lanjut untuk menampilkan\n</code></pre> Output:</p> <p>Jendela interaktif akan muncul, menampilkan bukit 3D yang bisa Anda putar, perbesar, dan lihat garis kontur hitam yang menunjukkan ketinggian.</p> <p></p>"},{"location":"python/basics/Membuat%20Topo%20dari%20Data%20Koordinat/#5-ekspor-kontur-ke-shapefile","title":"5. Ekspor Kontur ke Shapefile","text":"<p>Sintaks: <pre><code>contours = surf.contour(isosurfaces=10)\nlines = [LineString(contours.points[contours.lines[i+1:i+1+contours.lines[i]]])\n         for i in range(0, len(contours.lines), contours.lines[0]+1)]\ngdf = gpd.GeoDataFrame(geometry=lines, crs=\"EPSG:4326\")\ngdf.to_file(\"contours.shp\")\nprint(\"Contours exported as Shapefile: contours.shp\")\n</code></pre></p> <p>Tujuan:</p> <p>Ini seperti mengambil garis-garis ketinggian dari peta Anda dan menyimpannya ke dalam file yang bisa dibuka di aplikasi peta profesional (seperti QGIS). File ini berisi garis-garis kontur yang menunjukkan ketinggian tertentu di bukit Anda.</p> <p>Simmiliar Function:</p> <ul> <li>Anda bisa menulis garis-garis itu secara manual ke file seperti menulis di buku (fiona).</li> <li>Atau hanya membuat bentuk garis tanpa menyimpan langsung (shapely).</li> </ul> <p>Metode dan Fungsi lain yang dapat digunakan:</p> <p><pre><code># Menggunakan Fiona\nimport fiona\nfrom shapely.geometry import mapping\nschema = {'geometry': 'LineString', 'properties': {}}\nwith fiona.open('kontur_manual.shp', 'w', 'ESRI Shapefile', schema, crs='EPSG:4326') as c:\n    for line in lines:\n        c.write({'geometry': mapping(line), 'properties': {}})\nprint(\"Garis kontur disimpan dengan Fiona\")\n</code></pre> Output:</p> <p>File bernama <code>contours.shp</code> akan dibuat di folder Anda, yang bisa dibuka di aplikasi seperti QGIS, dan Anda akan melihat pesan: <code>Contours exported as Shapefile: contours.shp</code>.</p>"},{"location":"python/basics/Membuat%20Topo%20dari%20Data%20Koordinat/#6-ekspor-surface-kedalam-file-geotiff","title":"6. Ekspor Surface kedalam file GeoTIFF","text":"<p>Sintaks: <pre><code>points = surf.points\nx, y, z = points[:, 0], points[:, 1], points[:, 2]\ngrid_size = 100\nxi = np.linspace(min(x), max(x), grid_size)\nyi = np.linspace(min(y), max(y), grid_size)\nX, Y = np.meshgrid(xi, yi)\nZ = np.interp(X.ravel(), x, z).reshape(grid_size, grid_size)\ntransform = from_origin(min(x), max(y), (max(x)-min(x))/grid_size, (max(y)-min(y))/grid_size)\nwith rasterio.open(\"topography.tif\", \"w\", driver=\"GTiff\", height=Z.shape[0], width=Z.shape[1],\n                   count=1, dtype=Z.dtype, crs=\"EPSG:4326\", transform=transform) as dst:\n    dst.write(Z, 1)\nprint(\"Surface exported as GeoTIFF: topography.tif\")\n</code></pre></p> <p>Tujuan:</p> <p>Bayangkan Anda mengambil foto udara dari bukit Anda dan menyimpannya dalam format gambar khusus yang bisa dibaca oleh aplikasi peta. Sintaks ini membuat file gambar yang menunjukkan ketinggian di setiap titik di bukit Anda.</p> <p>Simmiliar Function:</p> <ul> <li>Anda bisa menggunakan alat khusus untuk membuat gambar peta (gdal).</li> <li>Atau mengedit gambar terlebih dahulu seperti di aplikasi foto (PIL).</li> </ul> <p>Metode dan Fungsi lain yang dapat digunakan:</p> <p><pre><code># Menggunakan GDAL\nfrom osgeo import gdal\ndriver = gdal.GetDriverByName('GTiff')\ndataset = driver.Create('foto_bukit.tif', 100, 100, 1, gdal.GDT_Float32)\ndataset.SetGeoTransform((min(x), (max(x)-min(x))/100, 0, max(y), 0, -(max(y)-min(y))/100))\ndataset.SetProjection('EPSG:4326')\ndataset.GetRasterBand(1).WriteArray(Z)\ndataset.FlushCache()\nprint(\"Foto bukit disimpan dengan GDAL\")\n</code></pre> Output:</p> <p>File bernama <code>topography.tif</code> akan dibuat, yang bisa dibuka di aplikasi seperti QGIS untuk melihat peta ketinggian, dan Anda akan melihat pesan: <code>Surface exported as GeoTIFF: topography.tif</code>.</p>"},{"location":"python/basics/Membuat%20Topo%20dari%20Data%20Koordinat/#kesimpulan","title":"Kesimpulan","text":"<p>Modul ini seperti panduan untuk mengubah catatan ketinggian bukit Anda menjadi peta 3D yang menarik. Anda bisa melihatnya sebagai gambar sederhana <code>(Matplotlib)</code>, model interaktif <code>(Pyvista)</code>, atau menyimpannya sebagai file peta <code>(Shapefile dan GeoTIFF)</code> untuk digunakan di aplikasi profesional. Dengan Simmiliar Function, Anda bisa menyesuaikan cara membaca data, menggambar, atau menyimpan sesuai kebutuhan Anda. Semoga cerita dan analogi ini membantu Anda memahami Sintaks dengan lebih mudah dan menyenangkan! Jika ada yang ingin diperjelas lagi, silakan beri tahu saya.</p>"},{"location":"python/basics/Membuat%20Topo%20dari%20Data%20Koordinat/#file-jupyter-notebook-ipynb-dan-data-yang-digunakan-pada-modul-ini-dapat-diakses-pada-link-dibawah","title":"File Jupyter Notebook (.ipynb) dan data yang digunakan pada modul ini dapat diakses pada Link dibawah:","text":"<p>Data dalam format.csv</p>"},{"location":"python/intermediate/none/","title":"Empty","text":""},{"location":"python/intermediate/none/#hopefully-will-done-sooner","title":"Hopefully will Done Sooner","text":""}]}