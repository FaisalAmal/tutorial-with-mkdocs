{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"about/","title":"About GeoPython Learn","text":"<p>Our mission is to provide accessible, high-quality resources for geologists and learners to master Python in geological applications.</p> <p>Our mission is to provide accessible, high-quality resources for geologists and learners to master Python in geological applications.</p>"},{"location":"resources/","title":"Resources","text":"<ul> <li>Python Official Documentation</li> <li>Pandas for Data Analysis</li> <li>Matplotlib for Visualization</li> </ul>"},{"location":"geology/geology%20structure/none/","title":"Empty","text":""},{"location":"geology/geology%20structure/none/#hopefully-will-done-sooner","title":"Hopefully will Done Sooner","text":""},{"location":"geology/petrology/none/","title":"Empty","text":""},{"location":"geology/petrology/none/#hopefully-will-done-sooner","title":"Hopefully will Done Sooner","text":""},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/","title":"3D Geological Model with Gempy","text":""},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#pendahuluan","title":"Pendahuluan","text":"<p>Panduan ini disusun menggunakan Python dengan library seperti <code>pandas</code>, <code>numpy</code>, <code>gempy</code>, dan <code>gempy_viewer</code> untuk memproses data drill hole (collar, survey, litologi, dan assay) serta membuat model geologi 3D. Data yang digunakan dalam tutorial ini menggunakan data endapan nikel laterit dengan litologi seperti LIM (limonit), SAP (saprolit), dan BZ (batuan dasar). Adapun proses yang dilakukan meliputi penginputan data, desurvey drill hole, pengolahan litologi, pengaturan model geologi, penghitungan, dan visualisasi hasil dalam 2D dan 3D.</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-1-pengaturan-dan-impor-library","title":"Blok 1: Pengaturan dan Impor library","text":"<p><pre><code># Install library yang diperlukan jika belum terinstall\n# pip install pandas numpy pyvista matplotlib gempy gempy_viewer\n\nimport os\nos.environ[\"DEFAULT_BACKEND\"] = \"PYTORCH\"\n\nimport pandas as pd\nimport numpy as np\nimport gempy as gp\nimport gempy_viewer as gpv\nfrom pyvista import set_plot_theme\nset_plot_theme('document')\n</code></pre> - Tujuan: Menyiapkan environment dengan mengimpor library yang diperlukan dan mengatur konfigurasi. - Langkah-langkah:   - Mengatur variabel environment <code>DEFAULT_BACKEND</code> ke <code>\"PYTORCH\"</code> untuk perhitungan GemPy (PyTorch digunakan untuk operasi numerik yang lebih cepat).   - Mengimpor <code>pandas</code> untuk penanganan data, <code>numpy</code> untuk operasi numerik, <code>gempy</code> untuk pemodelan geologi, dan <code>gempy_viewer</code> untuk visualisasi.   - Mengatur tema plot PyVista ke <code>'document'</code> untuk tampilan bersih bergaya publikasi. - Output: Mencetak <code>\"Setting Backend To: AvailableBackends.PYTORCH\"</code>.</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-2-memuat-dan-menampilkan-data","title":"Blok 2: Memuat dan Menampilkan Data","text":"<p><pre><code># Memuat data Anda\ncollar = pd.read_csv('collar.csv')  # hole_id, y, x, z\nsurvey = pd.read_csv('survey.csv')  # hole_id, dip, azimuth, depth\nlithology = pd.read_csv('lithology.csv')  # hole_id, from_depth, to_depth, lithology\nassay = pd.read_csv('assay.csv')  # hole_id, from_depth, to_depth, nickel_grade\n\nprint(collar.head(), survey.head(), lithology.head(), assay.head())\n</code></pre> - Tujuan: Memuat data drill hole dari file CSV dan menampilkan lima baris pertama dari setiap dataset. - Langkah-langkah:   - Memuat empat dataset:     - <code>collar</code>: Lokasi collar drill hole (BHID, XCOLLAR, YCOLLAR, ZCOLLAR).     - <code>survey</code>: Data survei drill hole (BHID, DEPTH, AZIMUTH, DIP).     - <code>lithology</code>: Interval litologi (BHID, Fr., To, LITOLOGI).     - <code>assay</code>: Data assay dengan kadar nikel (BHID, Fr., To, Total Ni, dll.).   - Menggunakan <code>head()</code> dari <code>pandas</code> untuk melihat pratinjau data. - Output: Menampilkan contoh baris dari setiap DataFrame, menunjukkan ID drill hole, koordinat, kedalaman, kemiringan, azimuth, litologi (misalnya LIM), dan nilai assay (misalnya kadar nikel).</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-3-mengganti-nama-kolom","title":"Blok 3: Mengganti Nama Kolom","text":"<p><pre><code>collar = collar.rename(columns={'BHID': 'hole_id', 'YCOLLAR': 'y', 'XCOLLAR': 'x', 'ZCOLLAR': 'z'})\nsurvey = survey.rename(columns={'BHID': 'hole_id', 'DIP ': 'dip', 'AZIMUTH': 'azimuth', 'DEPTH': 'depth'})\nlithology = lithology.rename(columns={'BHID': 'hole_id', 'Fr.': 'from_depth', 'To': 'to_depth', 'LITOLOGI': 'lithology'})\nassay = assay.rename(columns={'BHID': 'hole_id', 'Fr.': 'from_depth', 'To': 'to_depth', 'Total Ni': 'nickel_grade'})\n\nprint(collar.head(), survey.head(), lithology.head(), assay.head())\n</code></pre> - Tujuan: Menstandarkan nama kolom untuk konsistensi dan kompatibilitas dengan GemPy. - Langkah-langkah:   - Mengganti nama kolom di setiap DataFrame menjadi nama yang konsisten dan deskriptif (misalnya, <code>BHID</code> \u2192 <code>hole_id</code>, <code>XCOLLAR</code> \u2192 <code>x</code>).   - Mencetak DataFrame yang diperbarui untuk memastikan perubahan. - Output: Sama seperti Blok 2, tetapi dengan nama kolom yang diperbarui (misalnya, <code>hole_id</code>, <code>x</code>, <code>y</code>, <code>z</code>, dll.).</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-4-desurvey-drill-hole","title":"Blok 4: Desurvey drill hole","text":"<p>Blok ini panjang, jadi saya akan membaginya menjadi dua bagian untuk kejelasan.</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#bagian-41-mendefinisikan-fungsi-desurvey","title":"Bagian 4.1: Mendefinisikan Fungsi Desurvey","text":"<p><pre><code>def desurvey(hole_collar, hole_survey, depth_interval=1):\n    hole_survey = hole_survey.sort_values('depth')\n    depths = hole_survey['depth'].values\n    dips = hole_survey['dip'].values\n    azimuths = hole_survey['azimuth'].values\n    current_x = hole_collar['x'].iloc[0]\n    current_y = hole_collar['y'].iloc[0]\n    current_z = hole_collar['z'].iloc[0]\n    desurveyed_points = []\n\n    for i in range(len(depths)):\n        if i == 0:\n            start_depth = 0\n            end_depth = depths[0]\n            start_dip = 0\n            start_azimuth = 0\n            end_dip = dips[0]\n            end_azimuth = azimuths[0]\n        else:\n            start_depth = depths[i-1]\n            end_depth = depths[i]\n            start_dip = dips[i-1]\n            start_azimuth = azimuths[i-1]\n            end_dip = dips[i]\n            end_azimuth = azimuths[i]\n\n        avg_dip = (start_dip + end_dip) / 2\n        avg_azimuth = (start_azimuth + end_azimuth) / 2\n        delta_d = end_depth - start_depth\n        if delta_d &lt;= 0:\n            continue\n        dip_rad = np.radians(avg_dip)\n        azimuth_rad = np.radians(avg_azimuth)\n        delta_z = -delta_d * np.cos(dip_rad)\n        delta_x = delta_d * np.sin(dip_rad) * np.cos(azimuth_rad)\n        delta_y = delta_d * np.sin(dip_rad) * np.sin(azimuth_rad)\n\n        num_points = int(np.ceil(delta_d / depth_interval))\n        for j in range(num_points + 1):\n            d = start_depth + j * depth_interval\n            if d &gt; end_depth:\n                d = end_depth\n            fraction = (d - start_depth) / delta_d if delta_d &gt; 0 else 0\n            x = current_x + fraction * delta_x\n            y = current_y + fraction * delta_y\n            z = current_z + fraction * delta_z\n            desurveyed_points.append({'depth': d, 'x': x, 'y': y, 'z': z})\n        current_x += delta_x current_y += delta_y\n        current_z += delta_z\n\n    return pd.DataFrame(desurveyed_points)\n</code></pre> - Tujuan: Mendefinisikan fungsi untuk menghitung koordinat 3D di sepanjang jalur drill hole berdasarkan data survei (kemiringan, azimuth, kedalaman). - Langkah-langkah:   - Mengambil <code>hole_collar</code> (titik awal) dan <code>hole_survey</code> (perubahan kemiringan, azimuth, kedalaman) sebagai masukan.   - Mengurutkan data survei berdasarkan kedalaman dan mengiterasi melalui segmen-segmen.   - Untuk setiap segmen:     - Menghitung rata-rata kemiringan dan azimuth.     - Mengonversi ke radian dan menghitung offset 3D (<code>delta_x</code>, <code>delta_y</code>, <code>delta_z</code>) menggunakan trigonometri.     - Menginterpolasi titik pada interval 1 meter (<code>depth_interval=1</code>) antara kedalaman awal dan akhir.   - Mengembalikan DataFrame dengan titik-titik desurvey (<code>depth</code>, <code>x</code>, <code>y</code>, <code>z</code>).</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#bagian-42-menerapkan-desurvey-ke-semua-drill-hole","title":"Bagian 4.2: Menerapkan Desurvey ke Semua drill hole","text":"<p><pre><code>survey_grouped = survey.groupby('hole_id')\ndesurveyed_dict = {}\nfor hole_id, hole_survey in survey_grouped:\n    hole_collar = collar[collar['hole_id'] == hole_id]\n    if hole_collar.empty:\n        continue\n    desurveyed = desurvey(hole_collar, hole_survey)\n    desurveyed['hole_id'] = hole_id\n    desurveyed_dict[hole_id] = desurveyed\ndesurveyed_df = pd.concat(desurveyed_dict.values(), ignore_index=True)\n</code></pre> - Tujuan: Menerapkan fungsi desurvey ke semua drill hole dan menggabungkan hasilnya. - Langkah-langkah:   - Mengelompokkan data survei berdasarkan <code>hole_id</code>.   - Untuk setiap drill hole:     - Mengekstrak data collar-nya.     - Memanggil <code>desurvey</code> untuk menghitung titik-titik 3D.     - Menambahkan <code>hole_id</code> ke hasil dan menyimpannya dalam kamus.   - Menggabungkan semua titik desurvey menjadi satu DataFrame (<code>desurveyed_df</code>). - Output: Tidak ada Output langsung; menghasilkan <code>desurveyed_df</code> dengan koordinat 3D untuk semua drill hole.</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-5-memproses-litologi","title":"Blok 5: Memproses Litologi","text":"<p>Blok ini juga panjang, jadi saya akan membaginya menjadi beberapa bagian.</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#bagian-51-mendefinisikan-fungsi-pengolahan-litologi","title":"Bagian 5.1: Mendefinisikan Fungsi pengolahan Litologi","text":"<p><pre><code># Mendefinisikan urutan stratigrafi\nstrat_order = {'LIM': 0, 'SAP': 1, 'BZ': 2}\n\ndef process_lithology(hole_lithology):\n    hole_lithology = hole_lithology.sort_values('from_depth')\n    processed = []\n    current_lith = None\n    current_from = None\n    current_thickness = 0\n\n    for i, row in hole_lithology.iterrows():\n        lith = row['lithology']\n        from_depth = row['from_depth']\n        to_depth = row['to_depth']\n        thickness = to_depth - from_depth\n\n        if current_lith is None:\n            current_lith = lith\n            current_from = from_depth\n            current_thickness = thickness\n        elif strat_order.get(lith, 999) &lt; strat_order.get(current_lith, 999):  # Tidak sesuai urutan\n            if thickness &lt; current_thickness:\n                continue\n            else:\n                processed.append({'from_depth': current_from, 'to_depth': from_depth, 'lithology': current_lith})\n                current_lith = lith\n                current_from = from_depth\n                current_thickness = thickness\n        else:\n            if lith == current_lith:\n                current_thickness += thickness\n            else:\n                processed.append({'from_depth': current_from, 'to_depth': from_depth, 'lithology': current_lith})\n                current_lith = lith\n                current_from = from_depth\n                current_thickness = thickness\n\n    if current_lith:\n        processed.append({'from_depth': current_from, 'to_depth': to_depth, 'lithology': current_lith})\n\n    if not any(p['lithology'] == 'Basement' for p in processed):\n        last_to = processed[-1]['to_depth']\n        processed.append({'from_depth': last_to, 'to_depth': last_to + 1, 'lithology': 'Basement'})\n\n    return pd.DataFrame(processed)\n</code></pre> - Tujuan: Memproses interval litologi untuk memastikan urutan stratigrafi dan menggabungkan unit yang sama secara berurutan. - Langkah-langkah:   - Mendefinisikan <code>strat_order</code> (LIM \u2192 SAP \u2192 BZ).   - Mengurutkan data litologi berdasarkan kedalaman.   - Mengiterasi melalui interval:     - Menggabungkan interval berturut-turut dengan litologi yang sama.     - Menyelesaikan unit yang tidak sesuai urutan (misalnya SAP di atas LIM) dengan mempertahankan unit yang lebih tebal.     - Menambahkan lapisan tipis \u201cBasement\u201d di bagian bawah jika tidak ada.   - Mengembalikan DataFrame dengan interval yang diproses.</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#bagian-52-menerapkan-pengolahan-dan-menyiapkan-titik-permukaan","title":"Bagian 5.2: Menerapkan pengolahan dan Menyiapkan Titik Permukaan","text":"<p><pre><code># Menerapkan ke semua lubang\nlithology_grouped = lithology.groupby('hole_id')\nprocessed_lithology = pd.concat([process_lithology(group) for _, group in lithology_grouped], \n                                keys=lithology_grouped.groups.keys()).reset_index(level=0).rename(columns={'level_0': 'hole_id'})\n\n# Menyiapkan titik permukaan dan mengekstrak bagian atas LIM untuk topografi\nsurface_points = []\nlim_top_points = []  # Untuk topografi\nfor hole_id, hole_lithology in processed_lithology.groupby('hole_id'):\n    if hole_id not in desurveyed_dict:\n        continue\n    hole_desurveyed = desurveyed_dict[hole_id]\n    depth_to_coords = dict(zip(hole_desurveyed['depth'], hole_desurveyed[['x', 'y', 'z']].to_numpy()))\n\n    lim_found = False\n    for _, row in hole_lithology.iterrows():\n        from_depth = row['from_depth']\n        from_coords = depth_to_coords.get(from_depth)\n        if from_coords is not None:\n            surface_points.append({\n                'x': from_coords[0],\n                'y': from_coords[1],\n                'z': from_coords[2],\n                'formation': row['lithology']\n            })\n            # Menangkap bagian atas LIM\n            if row['lithology'] == 'LIM' and not lim_found:\n                lim_top_points.append({\n                    'x': from_coords[0],\n                    'y': from_coords[1],\n                    'z': from_coords[2]\n                })\n                lim_found = True  # Hanya mengambil LIM paling atas\n\npoints_df = pd.DataFrame(surface_points)\nlim_top_df = pd.DataFrame(lim_top_points)\n</code></pre> - Tujuan: Menerapkan pengolahan litologi ke semua drill hole dan menyiapkan titik permukaan untuk pemodelan. - Langkah-langkah:   - Mengelompokkan litologi berdasarkan <code>hole_id</code> dan memproses setiap kelompok.   - Menggabungkan hasil menjadi <code>processed_lithology</code>.   - Memetakan koordinat desurvey ke kedalaman litologi.   - Membuat:     - <code>surface_points</code>: Semua batas litologi dengan koordinat 3D.     - <code>lim_top_points</code>: Titik-titik paling atas LIM untuk topografi.   - Mengonversi ke DataFrame (<code>points_df</code>, <code>lim_top_df</code>).</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-6-menginisialisasi-model-geologi","title":"Blok 6: Menginisialisasi Model Geologi","text":"<p><pre><code>all_x = points_df['x'].values\nall_y = points_df['y'].values\nall_z = points_df['z'].values\n\nextent = [\n    np.min(all_x) - 5, np.max(all_x) + 5,\n    np.min(all_y) - 5, np.max(all_y) + 5,\n    np.min(all_z) - 10, np.max(all_z) + 10\n]\n\ngeo_model = gp.create_geomodel(\n    project_name='Nickel_Mine_Model',\n    extent=extent,\n    resolution=[20, 20, 20],\n    structural_frame=gp.data.StructuralFrame.initialize_default_structure()\n)\n\n# Mengatur bagian atas LIM sebagai topografi menggunakan set_topography_from_arrays\ntopography_points = lim_top_df[['x', 'y', 'z']].to_numpy()\ngp.set_topography_from_arrays(\n    grid=geo_model.grid,\n    xyz_vertices=topography_points  # Mengirimkan array penuh (n, 3)\n)\n\nprint(\"Grid aktif:\", geo_model.grid.active_grids)\n</code></pre> - Tujuan: Mengatur model geologi GemPy dengan luas dan topografi. - Langkah-langkah:   - Menentukan luas model berdasarkan koordinat minimum/maksimum dengan tambahan ruang.   - Membuat <code>geo_model</code> dengan resolusi grid 20x20x20.   - Menggunakan bagian atas LIM untuk menentukan topografi.   - Mencetak grid aktif (misalnya, DENSE, TOPOGRAPHY). - Output: <code>\"Grid aktif: GridTypes.DENSE|TOPOGRAPHY|NONE\"</code>.</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-7-mendefinisikan-elemen-struktural","title":"Blok 7: Mendefinisikan Elemen Struktural","text":"<p><pre><code>unique_lithologies = ['LIM', 'SAP', 'BZ']  # Menyertakan Basement secara eksplisit\ncolors = ['#33ABFF', '#FFA833', '#72A533']\n\nelements = []\nfor i, lith in enumerate(unique_lithologies):\n    lith_points = points_df[points_df['formation'] == lith]\n    if lith_points.empty:\n        continue\n    element = gp.data.StructuralElement(\n        name=lith,\n        color=colors[i],\n        surface_points=gp.data.SurfacePointsTable.from_arrays(\n            x=lith_points['x'].values,\n            y=lith_points['y'].values,\n            z=lith_points['z'].values,\n            names=lith\n        ),\n        orientations=gp.data.OrientationsTable.initialize_empty()\n    )\n    elements.append(element)\n\ngeo_model.structural_frame.structural_groups[0].elements = elements\ngeo_model.structural_frame.structural_groups[0].name = 'Stratigraphic_Series'\n</code></pre> - Tujuan: Menentukan lapisan stratigrafi (LIM, SAP, BZ) untuk model. - Langkah-langkah:   - Menetapkan warna untuk setiap litologi.   - Membuat objek <code>StructuralElement</code> dengan titik permukaan untuk setiap litologi.   - Menambahkan elemen ke kerangka struktural model sebagai seri stratigrafi.</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-8-menambahkan-orientasi","title":"Blok 8: Menambahkan Orientasi","text":"<p><pre><code>centroid_x = points_df['x'].mean()\ncentroid_y = points_df['y'].mean()\ncentroid_z = points_df['z'].mean()\n\ngp.add_orientations(\n    geo_model=geo_model,\n    x=[centroid_x],\n    y=[centroid_y],\n    z=[centroid_z],\n    elements_names=[elements[0].name],  # LIM\n    pole_vector=[np.array([0, 0, 1])]\n)\n</code></pre> - Tujuan: Menambahkan satu orientasi untuk mengasumsikan lapisan datar. - Langkah-langkah:   - Menghitung centroid dari semua titik permukaan.   - Menambahkan orientasi di centroid untuk LIM dengan vektor kutub vertikal (lapisan datar).</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-9-menonaktifkan-anisotropi","title":"Blok 9: Menonaktifkan Anisotropi","text":"<p><pre><code>geo_model.update_transform(gp.data.GlobalAnisotropy.NONE)\n</code></pre> - Tujuan: Menyederhanakan model dengan menonaktifkan anisotropi global (mengasumsikan perilaku lapisan seragam).</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-10-menghitung-model","title":"Blok 10: Menghitung Model","text":"<p><pre><code>gp.compute_model(geo_model, engine_config=gp.data.GemPyEngineConfig(dtype='float64'))\n</code></pre> - Tujuan: Menjalankan interpolasi geologi untuk menghitung model 3D. - Langkah-langkah:   - Menggunakan PyTorch dengan presisi 64-bit untuk perhitungan. - Output: <code>\"Solusi: 4 Tingkat Octree, 3 Mesh DualContouring\"</code>.</p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-11-visualisasi-2d","title":"Blok 11: Visualisasi 2D","text":"<p><pre><code>gpv.plot_2d(geo_model, cell_number='mid', direction='y', show_data=False, show_results=True)\n</code></pre> - Tujuan: Memplot penampang 2D melalui tengah model sepanjang sumbu Y. - Langkah-langkah:   - Memvisualisasikan model yang dihitung tanpa titik data mentah. - Output: Menampilkan plot 2D (gambar disertakan dalam notebook).</p> <p>Output </p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#blok-12-visualisasi-3d","title":"Blok 12: Visualisasi 3D","text":"<p><pre><code>plotter = gpv.plot_3d(\n    geo_model,\n    show_surfaces=True,\n    show_topography=True,\n    image=False,\n    plotter_type='basic',  # Lebih sederhana untuk performa\n    kwargs_plot_structured_grid={'opacity': 0.8, 'lighting': True}\n)\n</code></pre> - Tujuan: Membuat visualisasi 3D dari model. - Langkah-langkah:   - Menampilkan permukaan litologi dan topografi dengan opasitas 80% dan efek pencahayaan.   - Menggunakan plotter dasar untuk performa.</p> <p>Output </p>"},{"location":"python/advanced/3D%20Geological%20Model%20with%20Gempy/#ringkasan","title":"Ringkasan","text":"<p>Notebook ini memproses data drill hole untuk mengolah dan memvisualisasikan model geologi 3D dari data pertambangan nikel laterit. Langkah-langkah-langkah meliputi: 1. Memuat dan menyiapkan data. 2. Melakukan desurvey drill hole untuk mendapatkan koordinat 3D. 3. Memproses litologi untuk memastikan urutan stratigrafi. 4. Mengatur model GemPy dengan topografi dan elemen struktural. 5. Menghitung dan memvisualisasikan model dalam 2D dan 3D.</p>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/","title":"Data Automation for DrillHole Database","text":""},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#modul-automasi-pengolahan-database-pengeboran","title":"Modul: Automasi pengolahan database pengeboran","text":"<p>Developed by: Hamba ALLAH</p> <p>For further colaborations, feel free to reach me out with Hyperlink above</p>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#sekapur-sirih","title":"Sekapur Sirih","text":"<p>Modul ini diharapkan dapat membantu dalam pembuatan automasi database dengan meng-update data harian secara automatis (contoh kasus dalam modul ini menggunakan data pengeboran yang akan terus diupdate berdasarkan data titik bor yang finish). Semoga bermanfaat dan membawa kebaikan.</p>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#panduan-step-by-steps","title":"Panduan Step by Steps","text":""},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#langkah-1-menyiapkan-environment-tools","title":"Langkah 1: Menyiapkan Environment Tools","text":"<p>1. Install Python:</p> <ul> <li>Unduh dan install Python 3.11 atau lebih baru dari situs resmi Python.</li> <li>Saat instalasi, pastikan opsi \u201cTambahkan Python ke PATH\u201d dicentang untuk akses baris perintah.</li> <li>Verifikasi instalasi dengan membuka Command Prompt (Windows) atau Terminal (Mac/Linux) dan ketik <code>python --version</code>.</li> </ul> <p>2. Buat Folder Proyek:</p> <ul> <li>Buat folder bernama <code>DrillHole_Automation</code> di komputer Anda (misalnya, <code>C:\\Users\\NamaPenggunaAnda\\DrillHole_Automation</code>).</li> <li>Di dalamnya, buat subfolder <code>Daily_Data</code> untuk file data harian yang akan ditambahkan ke database.</li> </ul> <p>3. Install Library yang Diperlukan:</p> <ul> <li>Buka Command Prompt, navigasikan ke <code>DrillHole_Automation</code> (misalnya, <code>cd C:\\Users\\NamaPenggunaAnda\\DrillHole_Automation</code>), dan jalankan perintah dibawah:      <pre><code>pip install flask watchdog openpyxl pandas matplotlib\n</code></pre></li> <li>Perintah diatas menginstal library Flask (server web), Watchdog (pemantauan file), OpenPyXL (penanganan Excel), Pandas (manipulasi data), dan Matplotlib (visualisasi).</li> </ul> <p>4. Siapkan File database Anda:</p> <ul> <li>Siapkan format database, e.g: <code>drilling_database.xlsx</code> dalam folder <code>DrillHole_Automation</code> dengan format disesuaikan dengan format database yang dibutuhkan (misalnya, <code>Date Logging</code>, <code>Hole ID</code>, <code>From</code>, dll.).</li> <li>Pastikan file dapat diedit dan tidak dibuka di Excel selama eksekusi skrip.</li> </ul> <p>5. Siapkan File Data Harian:</p> <ul> <li>Letakkan file Excel harian sampel (misalnya, <code>daily-data.xlsx</code>) di <code>Daily_Data</code>. File ini harus mengikuti format konsisten dengan metadata (e.g: Nama titi bor sel B2, Tanggal di sel J3).</li> </ul>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#langkah-2-buat-skrip-utama-data_updaterpy","title":"Langkah 2: Buat Skrip Utama (<code>data_updater.py</code>)","text":"<p>Buat file bernama <code>data_updater.py</code> di <code>DrillHole_Automation</code>. Script kode pada bagian ini akan kami bagi menjadi beberapa bagian yang akan membantu memudahkan dalam memahami format kode. </p>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#bagian-1-impor-dan-konfigurasi","title":"Bagian 1: Impor dan Konfigurasi","text":"<p>Tujuan: Menyiapkan library yang diperlukan.</p> <p><pre><code>import matplotlib\nmatplotlib.use('Agg')  # Gunakan backend non-GUI untuk Matplotlib untuk menghindari masalah threading\n\nimport time\nfrom watchdog.observers import Observer\nfrom watchdog.events import FileSystemEventHandler\nfrom flask import Flask, request, render_template_string\nimport openpyxl\nimport threading\nimport os\nimport pandas as pd\nimport logging\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\nfrom io import BytesIO\nimport base64\n\n# Siapkan logging untuk debugging dan pelacakan\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Konfigurasi\ndaily_folder = r'Daily_Data'\ndatabase_file = r'C:\\Users\\NamaPenggunaAnda\\DrillHole_Automation\\drilling_database.xlsx'\n</code></pre> - Penjelasan:   - <code>matplotlib.use('Agg')</code> mencegah error terkait GUI (misalnya, konflik dengan Tkinter) dengan menggunakan backend non-interaktif.   - Flask digunakan untuk menampilkan data bebasis dashboard, pemantauan file (Watchdog), manipulasi Excel (OpenPyXL), analisis data (Pandas), dan visualisasi (Matplotlib).   - Logging melacak operasi untuk debugging.   - <code>daily_folder</code> dan <code>database_file</code> menentukan jalur file (sesuaikan <code>NamaPenggunaAnda</code> dengan nama pengguna Windows Anda atau gunakan <code>os.path.expanduser</code> untuk kompatibilitas lintas platform, misalnya, <code>os.path.expanduser('~') + '/DrillHole_Automation/drilling_database.xlsx'</code>).</p> <p>Potensi eror: - Masalah penempatan folder: Jika jalur <code>daily_folder</code> atau <code>database_file</code> tidak sesuai, Anda akan mendapatkan <code>FileNotFoundError</code>. Verifikasi jalur di File Explorer dan sesuaikan. - Error Instalasi Library: Potensi <code>pip install</code> gagal, pastikan ada akses internet atau periksa kompatibilitas versi Python.</p>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#bagian-2-pemantauan-sistem-file-dengan-watchdog","title":"Bagian 2: Pemantauan Sistem File dengan Watchdog","text":"<p>Tujuan: Mendeteksi folder <code>Daily_Data</code> untuk mendeteksi file Excel baru dan melakukan pemrosesan.</p> <p><pre><code>class Watcher:\n    def __init__(self):\n        self.observer = Observer()\n\n    def run(self):\n        event_handler = Handler()\n        self.observer.schedule(event_handler, daily_folder, recursive=False)\n        self.observer.start()\n        try:\n            while True:\n                time.sleep(1)\n        except KeyboardInterrupt:\n            self.observer.stop()\n        self.observer.join()\n\nclass Handler(FileSystemEventHandler):\n    def on_created(self, event):\n        if event.is_directory:\n            return\n        if event.src_path.endswith('.xls') atau event.src_path.endswith('.xlsx'):\n            logger.info(f\"File baru terdeteksi: {event.src_path}\")\n            try:\n                process_new_file(event.src_path)\n                logger.info(f\"Berhasil memproses file: {event.src_path}\")\n            except Exception as e:\n                logger.error(f\"Error memproses file {event.src_path}: {str(e)}\")\n</code></pre> - Penjelasan:   - <code>Watcher</code> membuat <code>Observer</code> untuk memantau <code>daily_folder</code> secara continue.   - <code>Handler</code> memantau pembuatan file, memfilter file <code>.xls</code> atau <code>.xlsx</code>, dan menjalankan <code>process_new_file</code> untuk mengolah file baru.   - <code>time.sleep(1)</code> mencegah overload CPU; <code>KeyboardInterrupt</code> menutup sistem ketika mengalami overload or stuck.</p> <p>Kemungkinan Eror: - Izin Ditolak: Jika <code>Daily_Data</code> tidak memiliki izin baca/tulis, <code>Watchdog</code> gagal. Periksa izin folder di Windows Explorer. - Penguncian File: Jika file dibuka di Excel, <code>Watchdog</code> mungkin memicu sebelum file sepenuhnya diedit, menyebabkan <code>PermissionError</code>. Tambahkan <code>time.sleep(2)</code> di <code>process_new_file</code> untuk menunda pemrosesan.</p>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#bagian-3-fungsi-pemrosesan-data","title":"Bagian 3: Fungsi Pemrosesan Data","text":"<p>Tujuan: Menganalisis, memindahkan, dan memperbarui data harian ke dalam database.</p> <p><pre><code>def process_new_file(file_path):\n    time.sleep(2)  # Pastikan file sepenuhnya ditulis\n    transformed_data = transform_data(file_path)\n    append_to_database(transformed_data)\n\ndef transform_data(file_path):\n    try:\n        wb = openpyxl.load_workbook(file_path, data_only=True)\n        sheet = wb.active\n\n        raw_hole_id = sheet['B2'].value\n        raw_date_logging = sheet['J3'].value\n        logger.info(f\"Metadata mentah dari {os.path.basename(file_path)} - B2: {raw_hole_id}, J3: {raw_date_logging}\")\n\n        hole_id = str(raw_hole_id).strip() if raw_hole_id else None\n        date_logging = raw_date_logging\n        if isinstance(date_logging, datetime):\n            date_logging = date_logging.date()\n        elif isinstance(date_logging, str):\n            try:\n                date_logging = datetime.strptime(date_logging, '%Y-%m-%d %H:%M:%S').date()\n            except ValueError:\n                date_logging = None\n\n        if not hole_id or not date_logging:\n            raise ValueError(f\"Missing or invalid Hole ID ({hole_id}) or Date Logging ({date_logging}) in metadata\")\n\n        daily_data = pd.read_excel(file_path, skiprows=7, header=0, usecols='B:V')\n        logger.info(f\"Kolom di {os.path.basename(file_path)}: {list(daily_data.columns)}\")\n\n        # Data kolom disesuaikan dengan format database yang dibuat atau dimiliki.\n        required_columns = ['FROM', 'TO', 'INTERVAL (M)', 'ACT CORE (M)', 'RECOVERY (%)',\n                           'GENERAL LITHOLOGY', 'SUB GEN LITHOLOGY', 'ROCK CODE', 'GRAIN SIZE',\n                           'WEATHERING', 'COLOUR', 'PRIMARY.1', 'SECONDARY.1', 'TERTIARY']\n        missing_columns = [col for col in required_columns if col not in daily_data.columns]\n        if missing_columns:\n            logger.warning(f\"Kolom yang diharapkan hilang: {missing_columns}. Kembali ke indeks.\")\n            daily_data = pd.read_excel(file_path, skiprows=8, header=None, usecols='B:V')\n            transformed_rows = []\n            for _, row in daily_data.iterrows():\n                if pd.isna(row[0]):\n                    continue\n                transformed_row = {\n                    'Date Logging': date_logging,\n                    'Hole ID': hole_id,\n                    'From': row[0],\n                    'To': row[1],\n                    'Length': row[2],\n                    'Actual Core': row[3],\n                    'Recovery pecentage': row[6] / 100 if pd.notna(row[6]) else 1.0,\n                    'Material Code': str(row[7]).lower() if pd.notna(row[7]) else '',\n                    'Layer Code': str(row[8]).lower() if pd.notna(row[8]) else '',\n                    'Rock Code': str(row[9]).lower() if pd.notna(row[9]) else '',\n                    'Grain': str(row[10]).lower() if pd.notna(row[10]) else '',\n                    'Weath': row[12] if pd.notna(row[12]) else None,\n                    'Colour': str(row[13]).lower() if pd.notna(row[13]) else '',\n                    'Minerals Pri': str(row[16]).lower() if pd.notna(row[16]) else '',\n                    'Minerals Sec': str(row[17]).lower() if pd.notna(row[17]) else '',\n                    'Minerals Ter': str(row[18]).lower() if pd.notna(row[18]) else '',\n                    'Bolder leght (m)': None\n                }\n                transformed_rows.append(transformed_row)\n        else:\n            transformed_rows = []\n            for _, row in daily_data.iterrows():\n                if pd.isna(row['FROM']):\n                    continue\n                transformed_row = {\n                    'Date Logging': date_logging,\n                    'Hole ID': hole_id,\n                    'From': row['FROM'],\n                    'To': row['TO'],\n                    'Length': row['INTERVAL (M)'],\n                    'Actual Core': row['ACT CORE (M)'],\n                    'Recovery pecentage': row['RECOVERY (%)'] / 100 if pd.notna(row['RECOVERY (%)']) else 1.0,\n                    'Material Code': str(row['GENERAL LITHOLOGY']).lower() if pd.notna(row['GENERAL LITHOLOGY']) else '',\n                    'Layer Code': str(row['SUB GEN LITHOLOGY']).lower() if pd.notna(row['SUB GEN LITHOLOGY']) else '',\n                    'Rock Code': str(row['ROCK CODE']).lower() if pd.notna(row['ROCK CODE']) else '',\n                    'Grain': str(row['GRAIN SIZE']).lower() if pd.notna(row['GRAIN SIZE']) else '',\n                    'Weath': row['WEATHERING'] if pd.notna(row['WEATHERING']) else None,\n                    'Colour': str(row['COLOUR']).lower() if pd.notna(row['COLOUR']) else '',\n                    'Minerals Pri': str(row['PRIMARY.1']).lower() if pd.notna(row['PRIMARY.1']) else '',\n                    'Minerals Sec': str(row['SECONDARY.1']).lower() if pd.notna(row['SECONDARY.1']) else '',\n                    'Minerals Ter': str(row['TERTIARY']).lower() if pd.notna(row['TERTIARY']) else '',\n                    'Bolder leght (m)': None\n                }\n                transformed_rows.append(transformed_row)\n        return transformed_rows\n    except Exception as e:\n        logger.error(f\"Error di transform_data: {str(e)}\")\n        raise\n\ndef append_to_database(transformed_rows):\n    try:\n        db_path = os.path.normpath(database_file)\n        logger.info(f\"Mencoba memperbarui database di: {db_path}\")\n\n        wb = openpyxl.load_workbook(db_path)\n        sheet = wb.active\n        last_row = sheet.max_row\n\n        if last_row == 1 and sheet.cell(row=1, column=1).value is None:\n            headers = ['Date Logging', 'Hole ID', 'From', 'To', 'Length', 'Actual Core', 'Recovery pecentage',\n                       'Material Code', 'Layer Code', 'Rock Code', 'Grain', 'Weath', 'Colour',\n                       'Minerals Pri', 'Minerals Sec', 'Minerals Ter', 'Bolder leght (m)']\n            for col, header in enumerate(headers, 1):\n                sheet.cell(row=1, column=col).value = header\n            last_row = 1\n\n        for row_data in transformed_rows:\n            last_row += 1\n            sheet.cell(row=last_row, column=1).value = row_data['Date Logging']\n            sheet.cell(row=last_row, column=2).value = row_data['Hole ID']\n            sheet.cell(row=last_row, column=3).value = row_data['From']\n            sheet.cell(row=last_row, column=4).value = row_data['To']\n            sheet.cell(row=last_row, column=5).value = row_data['Length']\n            sheet.cell(row=last_row, column=6).value = row_data['Actual Core']\n            sheet.cell(row=last_row, column=7).value = row_data['Recovery pecentage']\n            sheet.cell(row=last_row, column=8).value = row_data['Material Code']\n            sheet.cell(row=last_row, column=9).value = row_data['Layer Code']\n            sheet.cell(row=last_row, column=10).value = row_data['Rock Code']\n            sheet.cell(row=last_row, column=11).value = row_data['Grain']\n            sheet.cell(row=last_row, column=12).value = row_data['Weath']\n            sheet.cell(row=last_row, column=13).value = row_data['Colour']\n            sheet.cell(row=last_row, column=14).value = row_data['Minerals Pri']\n            sheet.cell(row=last_row, column=15).value = row_data['Minerals Sec']\n            sheet.cell(row=last_row, column=16).value = row_data['Minerals Ter']\n            sheet.cell(row=last_row, column=17).value = row_data['Bolder leght (m)']\n\n        wb.save(db_path)\n        logger.info(f\"Berhasil menambahkan {len(transformed_rows)} baris ke {db_path}\")\n    except Exception as e:\n        logger.error(f\"Error menambahkan ke database: {str(e)}\")\n        raise\n</code></pre> - Penjelasan:   - <code>process_new_file</code>: Mengkoordini pengolahan data dan memastikan ketersediaan file.   - <code>transform_data</code>: Membaca metadata (ID Lubang, Tanggal), memvalidasinya, dan mentransformasi data harian ke format database, menangani ketidaksesuaian header dengan indeks sebagai cadangan.   - <code>append_to_database</code>: Memperbarui <code>drilling_database.xlsx</code>, menambahkan header jika diperlukan, memastikan konsistensi data.</p> <p>Kemungkinan Eror: - Error Metadata: Jika cell excel <code>B2</code> atau <code>J3</code> kosong, gunakan log untuk debugging dan buat ulang file jika rusak. - Ketidaksesuaian Kolom: Jika header berbeda, log akan menunjukkan nama kolom; sesuaikan <code>transform_data</code> untuk indeks atau header. - Izin File: Pastikan akses tulis ke <code>drilling_database.xlsx</code>, periksa melalui properti Windows Explorer.</p>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#bagian-4-menampilakan-data-dengan-dashboard-sederhana-dengan-flask","title":"Bagian 4: Menampilakan data dengan dashboard sederhana dengan <code>Flask</code>","text":"<p>Tujuan: Menyediakan dashboard di internal komputer untuk visualisasi dan pembaruan manual.</p> <p><pre><code>app = Flask(__name__)\n\ndef load_database():\n    return pd.read_excel(database_file)\n\ndef generate_recovery_plot(df):\n    depth_avg = df.groupby('From')['Recovery pecentage'].mean().reset_index()\n    plt.figure(figsize=(10, 6))\n    plt.plot(depth_avg['From'], depth_avg['Recovery pecentage'], marker='o', linestyle='-', color='biru')\n    plt.title('Persentase Pemulihan Rata-rata vs. Kedalaman Rata-rata')\n    plt.xlabel('Kedalaman Rata-rata (m) - Dari')\n    plt.ylabel('Persentase Pemulihan Rata-rata')\n    plt.grid(True)\n    img = BytesIO()\n    plt.savefig(img, format='png', bbox_inches='tight')\n    plt.close()\n    return base64.b64encode(img.getvalue()).decode('utf-8')\n\ndef generate_material_distribution_plot(df):\n    material_counts = df['Material Code'].value_counts()\n    plt.figure(figsize=(10, 6))\n    material_counts.plot(kind='bar', color='ungu')\n    plt.title('Distribusi Kode Material')\n    plt.xlabel('Kode Material')\n    plt.ylabel('Jumlah')\n    plt.xticks(rotation=45)\n    plt.grid(axis='y')\n    img = BytesIO()\n    plt.savefig(img, format='png', bbox_inches='tight')\n    plt.close()\n    return base64.b64encode(img.getvalue()).decode('utf-8')\n\nDASHBOARD_TEMPLATE = \"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Dashboard Analitik DrillHole&lt;/title&gt;\n    &lt;style&gt;\n        body { font-family: Arial, sans-serif; margin: 0; background-color: #f5f7fa; color: #333; }\n        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }\n        .sidebar { width: 200px; float: left; background-color: #e9ecef; padding: 20px; height: 100vh; position: fixed; }\n        .content { margin-left: 220px; }\n        h1 { text-align: center; color: #2c3e50; margin-bottom: 20px; }\n        .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-bottom: 20px; }\n        .stat-card { background-color: white; border-radius: 8px; padding: 15px; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n        .stat-card h3 { margin: 0 0 5px 0; font-size: 14px; color: #7f8c8d; }\n        .stat-card p { margin: 0; font-size: 18px; color: #2c3e50; }\n        .plot-section { background-color: white; border-radius: 8px; padding: 20px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n        .plot { text-align: center; }\n        img { max-width: 100%; height: auto; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"sidebar\"&gt;\n        &lt;h2&gt;Navigasi&lt;/h2&gt;\n        &lt;ul style=\"list-style-type: none; padding: 0;\"&gt;\n            &lt;li&gt;&lt;a href=\"/\" style=\"color: #2c3e50; text-decoration: none;\"&gt;Dashboard&lt;/a&gt;&lt;/li&gt;\n            &lt;li&gt;&lt;a href=\"/update\" style=\"color: #2c3e50; text-decoration: none;\"&gt;Perbarui Data&lt;/a&gt;&lt;/li&gt;\n            &lt;li&gt;&lt;a href=\"/database-status\" style=\"color: #2c3e50; text-decoration: none;\"&gt;Status database&lt;/a&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/div&gt;\n    &lt;div class=\"content\"&gt;\n        &lt;div class=\"container\"&gt;\n            &lt;h1&gt;Dashboard Analitik DrillHole&lt;/h1&gt;\n            &lt;div class=\"stats-grid\"&gt;\n                &lt;div class=\"stat-card\"&gt;\n                    &lt;h3&gt;Total Lubang Pengeboran&lt;/h3&gt;\n                    &lt;p&gt;{{ total_holes }}&lt;/p&gt;\n                &lt;/div&gt;\n                &lt;div class=\"stat-card\"&gt;\n                    &lt;h3&gt;Kedalaman Rata-rata&lt;/h3&gt;\n                    &lt;p&gt;{{ avg_depth|round(2) }} m&lt;/p&gt;\n                &lt;/div&gt;\n                &lt;div class=\"stat-card\"&gt;\n                    &lt;h3&gt;Kedalaman Terdalam&lt;/h3&gt;\n                    &lt;p&gt;{{ deepest_depth|round(2) }} m&lt;/p&gt;\n                &lt;/div&gt;\n                &lt;div class=\"stat-card\"&gt;\n                    &lt;h3&gt;Kedalaman Terpendek&lt;/h3&gt;\n                    &lt;p&gt;{{ shallowest_depth|round(2) }} m&lt;/p&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"plot-section\"&gt;\n                &lt;h2&gt;Persentase Pemulihan Rata-rata vs. Kedalaman Rata-rata&lt;/h2&gt;\n                &lt;div class=\"plot\"&gt;\n                    {% if recovery_plot %}\n                        &lt;img src=\"data:image/png;base64,{{ recovery_plot }}\" alt=\"Plot Pemulihan\"&gt;\n                    {% else %}\n                        &lt;p&gt;Tidak ada data yang tersedia.&lt;/p&gt;\n                    {% endif %}\n                &lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"plot-section\"&gt;\n                &lt;h2&gt;Distribusi Kode Material&lt;/h2&gt;\n                &lt;div class=\"plot\"&gt;\n                    &lt;img src=\"data:image/png;base64,{{ material_plot }}\" alt=\"Distribusi Material\"&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\n@app.route('/', methods=['GET'])\ndef dashboard():\n    try:\n        df = load_database()\n        total_holes = len(df['Hole ID'].unique()) if not df.empty else 0\n        avg_depth = df['Length'].mean() if not df.empty else 0\n        deepest_depth = df['To'].max() if not df.empty else 0\n        shallowest_depth = df['From'].min() if not df.empty else 0\n        recovery_plot = generate_recovery_plot(df)\n        material_plot = generate_material_distribution_plot(df)\n        return render_template_string(DASHBOARD_TEMPLATE, total_holes=total_holes, avg_depth=avg_depth,\n                                     deepest_depth=deepest_depth, shallowest_depth=shallowest_depth,\n                                     recovery_plot=recovery_plot, material_plot=material_plot)\n    except Exception as e:\n        logger.error(f\"Error merender dashboard: {str(e)}\")\n        return f\"Error: {str(e)}\", 500\n\n@app.route('/update', methods=['GET', 'POST'])\ndef trigger_update():\n    try:\n        processed_files = []\n        for file in os.scandir(daily_folder):\n            if file.is_file() and (file.name.endswith('.xls') or file.name.endswith('.xlsx')):\n                process_new_file(file.path)\n                processed_files.append(file.name)\n        return {'status': 'success', 'processed_files': processed_files, 'message': 'Pembaruan manual dipicu'}\n    except Exception as e:\n        return {'status': 'error', 'message': str(e)}, 500\n\n@app.route('/database-status', methods=['GET'])\ndef database_status():\n    try:\n        wb = openpyxl.load_workbook(database_file)\n        sheet = wb.active\n        return {'status': 'success', 'last_row': sheet.max_row}, 200\n    except Exception as e:\n        return {'status': 'error', 'message': str(e)}, 500\n</code></pre> - Penjelasan:   - <code>load_database</code>: Memuat database untuk analisis.   - <code>generate_recovery_plot</code>, <code>generate_material_distribution_plot</code>: Membuat visualisasi, dideskripsikan sebagai base64 untuk dashboard.   - <code>DASHBOARD_TEMPLATE</code>: HTML dengan CSS untuk menampilkan dashboard, meliputi statistik dan plot.   - Rute menangani tampilan dashboard, pembaruan manual, dan pemeriksaan status database.</p> <p>Kemungkinan Eror: - Masalah Backend Matplotlib: Jika <code>matplotlib.use('Agg')</code> dilewatkan, expect error threading. Pastikan ada di awal skrip. - Error Memuat database: Jika <code>drilling_database.xlsx</code> hilang atau salah format, <code>pd.read_excel</code> gagal. Verifikasi keberadaan dan format file. - Error Rute Flask: Pastikan metode HTTP benar; sesuaikan jika terjadi error 405, seperti yang terlihat dengan <code>/update</code>.</p>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#bagian-5-menjalankan-sistem","title":"Bagian 5: Menjalankan Sistem","text":"<p>Tujuan: Jalankan skrip untuk memantau dan memperbarui data secara terus-menerus.</p> <p><pre><code>if __name__ == '__main__':\n    watcher_thread = threading.Thread(target=lambda: Watcher().run())\n    watcher_thread.daemon = True\n    watcher_thread.start()\n    app.run(host='127.0.0.1', port=5000)\n</code></pre> - Penjelasan:   - Menjalankan <code>Watcher</code> untuk pemantauan file pada folder yang telah ditentukan sebelumnya.   - Meluncurkan Flask di <code>localhost:5000</code>, dapat diakses melalui browser untuk dashboard.</p> <p>Kemungkinan Eror: - Konflik Port: Jika anda sedang menjalankan 5000 sebagai lokal host untuk projek lain maka Flask tidak dapat mengunakan host tersebut. Ubah ke <code>app.run(host='127.0.0.1', port=5001)</code> atau hapus poject yang bersangkutan. - Masalah Threading: Jika <code>Watcher</code> atau Flask crash, periksa log untuk pengecualian, memastikan izin dan akses file yang tepat.</p>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#langkah-3-ujicoba-dan-penanganan-masalah","title":"Langkah 3: Ujicoba dan Penanganan Masalah","text":"<ol> <li>Jalankan Skrip:</li> <li>Buka Command Prompt di <code>DrillHole_Automation</code>, ketik <code>python data_updater.py</code>, dan tekan Enter.</li> <li> <p>Periksa log untuk konfirmasi (misalnya, <code>File baru terdeteksi</code>).</p> </li> <li> <p>Tambahkan File Uji:</p> </li> <li> <p>Salin <code>daily-data.xlsx</code> ke <code>Daily_Data</code> dan verifikasi pembaruan database, memeriksa log untuk keberhasilan atau error.</p> </li> <li> <p>Akses Dashboard:</p> </li> <li>Buka browser di <code>http://127.0.0.1:5000</code> untuk melihat statistik dan plot.</li> <li> <p>Gunakan tautan sidebar untuk menguji <code>/update</code> dan <code>/database-status</code>.</p> </li> <li> <p>Tangani Kesalahan:</p> </li> <li>Masalah Metadata: Jika <code>Missing or invalid metadata</code>, buka <code>daily-data.xlsx</code>, pastikan <code>B2</code> dan <code>J3</code> memiliki data, dan log nilai mentah untuk debugging.</li> <li>Ketidaksesuaian Kolom: Jika <code>KeyError</code>, log <code>daily_data.columns</code> dan sesuaikan <code>transform_data</code> untuk indeks atau header.</li> <li>Error Matplotlib: Jika <code>RuntimeError</code>, pastikan <code>matplotlib.use('Agg')</code> ada di awal skrip.</li> <li>Error 405: Jika <code>/update</code> gagal, verifikasi eror tersebut dengan melihat GET di dashboard.</li> </ol>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#penanganan-kesalahan-rinci-dan-solusi","title":"Penanganan Kesalahan Rinci dan Solusi","text":"Kesalahan Penyebab Solusi <code>FileNotFoundError</code> untuk <code>daily_folder</code> Jalur folder atau file salah Verifikasi jalur, gunakan <code>os.path.exists()</code> untuk memeriksa <code>PermissionError</code> untuk akses file File terkunci atau tidak ada izin Tutup Excel, periksa izin Windows <code>KeyError: 'FROM'</code> Header hilang atau salah nama di file harian Log kolom, gunakan indeks, pastikan format file <code>ValueError: Missing or invalid metadata</code> Sel <code>B2</code> atau <code>J3</code> kosong atau salah format Buka file, verifikasi data, log nilai mentah, buat ulang <code>RuntimeError: main thread not in main loop</code> Konflik backend Matplotlib Tkinter Gunakan <code>matplotlib.use('Agg')</code> di awal skrip <code>405 Method Not Allowed</code> untuk <code>/update</code> Permintaan GET ke rute POST-only Tambah <code>methods=['GET', 'POST']</code> ke rute <code>/update</code> <code>Port Already in Use</code> untuk Flask Port 5000 sedang digunakan Ubah ke port lain (misalnya, 5001)"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#kesimpulan","title":"Kesimpulan","text":"<p>Panduan ini diharapkan membantu Anda membuat, menguji, dan memelihara sistem automasi data pengeboran di lokal komputer, menangani kesalahan melalui logging dan penyesuaian dari format data harian ke format database. Sistem ini mengotomatisasi pembaruan, menyediakan dashboard untuk memantau data, dan beroperasi secara offline, ideal untuk lingkungan kerja lapangan yang terkendala akses internet.</p>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#peningkatan-potensial","title":"Peningkatan Potensial","text":"<ul> <li>Tambahkan validasi data untuk penanganan error yang lebih kuat.</li> <li>Gunakan Plotly untuk visualisasi interaktif di dashboard.</li> <li>Implementasikan cadangan terjadwal untuk <code>drilling_database.xlsx</code>.</li> </ul>"},{"location":"python/advanced/Data%20Automation%20for%20DrillHole%20Database/#referensi","title":"Referensi","text":"<ul> <li>Dokumentasi Resmi Flask</li> <li>Library Watchdog Python</li> <li>Dokumentasi OpenPyXL</li> <li>Dokumentasi Pandas</li> <li>Dokumentasi Matplotlib</li> </ul>"},{"location":"python/basics/Basic%20Geology%20Tools/","title":"Basic Geology Tools","text":""},{"location":"python/basics/Basic%20Geology%20Tools/#introduction","title":"Introduction","text":"<p>Geologists often work with large datasets containing information about rock formations, mineral deposits, geochemical compositions, and elevation data. Before applying any analysis, it\u2019s essential to properly read, clean, and manipulate the data.</p> <p></p>"},{"location":"python/basics/Basic%20Geology%20Tools/#in-this-phase-we-will-focus-on","title":"In this phase, we will focus on:","text":"<p>\u2705 Loading geological datasets (CSV, Excel, JSON). \u2705 Performing basic data cleaning and manipulation using Pandas. \u2705 Conducting numerical operations with NumPy for geological computations.</p>"},{"location":"python/basics/Basic%20Geology%20Tools/#step-1-installing-the-required-libraries","title":"\ud83d\udcd6 Step 1: Installing the Required Libraries","text":"<p>Before working with Pandas and NumPy, make sure they are installed in your Python environment.</p> <pre><code>pip install pandas numpy\n\nimport pandas as pd\nimport numpy as np\n</code></pre>"},{"location":"python/basics/Basic%20Geology%20Tools/#step-2-loading-geological-datasets","title":"\ud83d\udcd6 Step 2: Loading Geological Datasets","text":"<p>Most geological data comes in the form of CSV (Comma-Separated Values), Excel, or JSON files. Here\u2019s how to read them:</p> <p>\ud83d\udd39 Loading a CSV File (Example: Rock Composition Data)</p> <p>Note: This command loads a CSV file into a Pandas DataFrame and displays the first five rows.</p> <pre><code>df = pd.read_csv(\"geological_data.csv\")\nprint(df.head())  # Display the first 5 rows\n</code></pre> <p>\ud83d\udd39 Loading an Excel File (Example: Mineral Deposits Data)</p> <p>Note: If the Excel file contains multiple sheets, specify the sheet_name parameter.</p> <pre><code>df = pd.read_excel(\"mineral_deposits.xlsx\", sheet_name=\"Sheet1\")\nprint(df.head())\n</code></pre> <p>\ud83d\udd39 Loading a JSON File (Example: Geological Site Data)</p> <p>Note: JSON files are often used for spatial data and can be converted into GeoDataFrames for GIS applications.</p> <pre><code>df = pd.read_json(\"geological_sites.json\")\nprint(df.head())\n</code></pre>"},{"location":"python/basics/Basic%20Geology%20Tools/#step-3-understanding-the-dataset","title":"\ud83d\udcd6 Step 3: Understanding the Dataset","text":"<p>After loading the dataset, it's important to inspect it:</p> <p>\ud83d\udd39 This step helps in understanding the structure of the dataset before processing it.</p> <pre><code>print(df.info())   # Summary of the dataset (columns, data types, null values)\nprint(df.describe())  # Statistical summary (mean, min, max, etc.)\nprint(df.columns)  # List of column names\nprint(df.shape)  # Number of rows and columns\n</code></pre>"},{"location":"python/basics/Basic%20Geology%20Tools/#step-4-cleaning-the-data","title":"\ud83d\udcd6 Step 4: Cleaning the Data","text":"<p>\ud83d\udd39 Handling Missing Values Sometimes, geological datasets have missing values (e.g., unrecorded mineral concentrations).</p> <pre><code>df = df.dropna()  # Remove rows with missing values\n# OR fill missing values with a default value\ndf = df.fillna(0)\n</code></pre> <p>\ud83d\udd39 Renaming Columns for Better Understanding</p> <pre><code>df = df.rename(columns={\"SiO2\": \"Silicon Dioxide\", \"Fe2O3\": \"Iron Oxide\"})\n</code></pre> <p>\ud83d\udd39 Filtering Data (Example: Extracting Data for Specific Rock Types)</p> <pre><code>sandstone_df = df[df[\"Rock_Type\"] == \"Sandstone\"]\nprint(sandstone_df)\n</code></pre>"},{"location":"python/basics/Basic%20Geology%20Tools/#step-5-basic-data-manipulation-with-pandas","title":"\ud83d\udcd6 Step 5: Basic Data Manipulation with Pandas","text":"<p>\ud83d\udd39 Selecting Specific Columns</p> <pre><code>selected_columns = df[[\"Rock_Type\", \"SiO2\", \"Fe2O3\"]]\nprint(selected_columns.head())\n</code></pre> <p>\ud83d\udd39 Sorting the Data by Mineral Concentration</p> <pre><code>df_sorted = df.sort_values(by=\"SiO2\", ascending=False)\nprint(df_sorted.head())\n</code></pre> <p>\ud83d\udd39 Creating New Columns (Example: Calculating Mineral Ratios)</p> <pre><code>df[\"SiO2_Fe2O3_Ratio\"] = df[\"SiO2\"] / df[\"Fe2O3\"]\nprint(df.head())\n</code></pre>"},{"location":"python/basics/Basic%20Geology%20Tools/#step-6-numerical-computations-with-numpy","title":"\ud83d\udcd6 Step 6: Numerical Computations with NumPy","text":"<p>\ud83d\udd39 Convert a Column to a NumPy Array</p> <pre><code>siO2_array = df[\"SiO2\"].values\nprint(siO2_array)\n</code></pre> <p>\ud83d\udd39 Compute Basic Statistics (Mean, Median, Standard Deviation)</p> <pre><code>mean_sio2 = np.mean(siO2_array)\nmedian_sio2 = np.median(siO2_array)\nstd_sio2 = np.std(siO2_array)\n\nprint(f\"Mean SiO2: {mean_sio2}, Median SiO2: {median_sio2}, Std Dev SiO2: {std_sio2}\")\n</code></pre> <p>\ud83d\udd39 Perform Mathematical Operations on an Entire Column</p> <p>\ud83d\udd39 This normalizes the SiO2 values between 0 and 1, useful for machine learning applications.</p> <pre><code>df[\"Normalized_SiO2\"] = (df[\"SiO2\"] - np.min(df[\"SiO2\"])) / (np.max(df[\"SiO2\"]) - np.min(df[\"SiO2\"]))\nprint(df.head())\n</code></pre>"},{"location":"python/basics/Basic%20Geology%20Tools/#step-7-exporting-processed-data","title":"\ud83d\udcd6 Step 7: Exporting Processed Data","text":"<p>After cleaning and processing, the data can be saved back to a file for further analysis.</p> <pre><code>df.to_csv(\"processed_geological_data.csv\", index=False)\ndf.to_excel(\"processed_geological_data.xlsx\", index=False)\ndf.to_json(\"processed_geological_data.json\")\n</code></pre>"},{"location":"python/intermediate/none/","title":"Empty","text":""},{"location":"python/intermediate/none/#hopefully-will-done-sooner","title":"Hopefully will Done Sooner","text":""}]}